# PRD - P1 轮询循环（正确的两阶段分离）

## 需求来源

用户需求：P1 阶段应该持续轮询 CI，失败则修复并继续循环，成功则自动合并。

## 核心问题

之前的实现（PR #263）违背了两阶段分离原则：
- P0 创建 PR 后直接调用 Step 9 进入轮询（一个会话做完所有事）
- Stop Hook 没有机会在 PR 创建后触发 exit 0
- 无法实现会话分离

## 正确设计

### 两次会话，两个阶段

```
【会话 1 - P0 阶段】
/dev → PRD → 代码 → 质检 → PR 创建
    ↓
Stop Hook 检查: PR 已创建 → exit 0 ✅ 会话结束

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【会话 2 - P1 阶段】（用户问"怎么样了"）
阶段检测 → PHASE: p1
    ↓
进入 09-ci.md 轮询循环:
  while true; do
    检查 CI 状态
    case:
      in_progress/queued/pending → sleep 30s, continue
      failure → 修复代码 → push → continue（继续轮询）
      success → 合并 PR → break（退出循环）
  done
    ↓
✅ 会话结束
```

## 核心改动

### 1. Step 8 (08-pr.md)
- PR 创建后**结束本步骤**（不调用 Step 9）
- 由 Stop Hook 检测到 PR 已创建 → exit 0 结束会话

### 2. Step 9 (09-ci.md)
- 改为**轮询循环模式**（在 P1 阶段执行）
- 不再是"事件驱动"（修复一次就退出）
- 而是**无限循环直到成功**

### 3. 阶段检测 (detect-phase.sh)
- P1 阶段检测到后，触发执行 Step 9
- Step 9 内部包含完整的轮询循环逻辑

## 关键设计点

### P0 阶段（会话 1）
```bash
# Step 8 结尾
gh pr create ...
echo "✅ PR 已创建: $PR_URL"
# 不调用 Step 9！
# Stop Hook 会检测到 PR 已创建，触发 exit 0
```

### P1 阶段（会话 2）
```bash
# Step 9 完整轮询循环
while true; do
  CI_STATUS=$(获取状态)

  if [ 运行中 ]; then
    sleep 30
    continue
  fi

  if [ 失败 ]; then
    # 修复代码
    git add && git commit && git push
    # 继续循环（不退出！）
    continue
  fi

  if [ 成功 ]; then
    gh pr merge --squash --delete-branch
    break  # 退出循环
  fi
done
```

## 涉及文件

修改：
- `skills/dev/steps/08-pr.md` - PR 创建后结束（不调用 Step 9）
- `skills/dev/steps/09-ci.md` - 改为完整的轮询循环
- `skills/dev/SKILL.md` - 更新流程图
- `package.json` - 版本号 10.3.0 → 10.4.0
- `CHANGELOG.md` - 添加 v10.4.0
- `regression-contract.yaml` - 更新 RCI
- `features/feature-registry.yml` - 更新 W1 feature
- `hook-core/VERSION` - 更新版本

## 成功标准

- [ ] Step 8 创建 PR 后不调用 Step 9
- [ ] Stop Hook 在 PR 创建后能够触发 exit 0
- [ ] Step 9 包含完整的 while 轮询循环
- [ ] P1 阶段能够持续循环直到成功
- [ ] npm run typecheck 通过
- [ ] npm run test 通过
