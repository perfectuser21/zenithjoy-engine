---
id: prd-ralph-loop-fix
version: 1.0.0
created: 2026-01-27
priority: P0
---

# PRD - Ralph Loop 自动调用修复（统一循环机制）

## 问题背景

当前文档混合了两种模式：
1. ❌ **旧模式（事件驱动）**：AI 手动循环，exit 0 退出等外部唤醒
2. ✅ **新模式（Ralph Loop）**：插件自动循环，检测 promise 结束

**核心问题**：AI 看到"结束对话"、"退出"、"允许结束"等关键词后会停下来，打断 Ralph Loop 的自动循环。

**实际案例**：
- 用户说"继续修复 CI"
- AI 手动循环了 4 次（查日志 → 修复 → push → 等 CI）
- 应该是：调用 `/ralph-loop` 一次，自动循环直到 CI 通过

---

## 核心矛盾清单

### 🔴 矛盾分类 1：文档描述的"结束"行为

| 文件位置 | 行号 | 错误描述 | 问题 |
|---------|------|---------|------|
| `skills/dev/SKILL.md` | L62 | `p0 阶段：PR 创建成功后（Stop Hook 允许结束）` | AI 会停下来 |
| `skills/dev/SKILL.md` | L136 | `结束对话 ✅ （不等 CI）` | 打断 Ralph Loop |
| `skills/dev/SKILL.md` | L172 | `结束对话 ✅ （PR 已合并）` | 打断 Ralph Loop |
| `skills/dev/SKILL.md` | L249 | `p1: CI pending → exit 0（退出，等唤醒）` | 打断循环 |
| `skills/dev/steps/08-pr.md` | L3-4 | `p0 阶段在此结束：PR 创建后立即结束对话，不等待 CI` | 打断 Ralph Loop |
| `skills/dev/steps/08-pr.md` | L126 | `Stop Hook 返回 exit 0，允许会话结束` | 打断 Ralph Loop |
| `skills/dev/steps/09-ci.md` | L52 | `结束对话 ✅ （GitHub 自动 merge）` | 打断 Ralph Loop |
| `skills/dev/steps/09-ci.md` | L73 | `exit 0` (CI pending 时) | AI 退出 |
| `skills/dev/steps/09-ci.md` | L216-219 | `Stop Hook: CI pending → exit 0，等待外部唤醒` | 打断循环 |
| `skills/dev/steps/09-ci.md` | L281 | `直接 exit 0 允许结束` | 打断 Ralph Loop |
| `hooks/stop.sh` | L16 | 注释：`p1: CI pending → exit 0（退出，等下次唤醒）` | 文档误导（实际代码是 exit 2）|
| `hooks/stop.sh` | L284 | `exit 0: p0 阶段结束，允许会话结束` | 打断 Ralph Loop |

### 🔴 矛盾分类 2：用 bash 循环代替 Ralph Loop

| 文件位置 | 行号 | 错误描述 | 问题 |
|---------|------|---------|------|
| `skills/dev/steps/09-ci.md` | L90-198 | 用 `while true; do ... done` 描述循环 | AI 误以为要写 bash 循环 |
| `skills/dev/steps/09.5-pending-wait.md` | L29-81 | 用 `while true; do ... done` 示例代码 | AI 误以为要写 bash 循环 |
| `skills/dev/SKILL.md` | L150-175 | 流程图中用 `while true` 描述 p1 循环 | 描述性文字，但 AI 会误解 |

### 🔴 矛盾分类 3：缺少 Ralph Loop 强制调用指令

| 文件位置 | 问题 |
|---------|------|
| `skills/dev/SKILL.md` 开头 | ❌ 没有"进入 /dev 必须调用 /ralph-loop"的强制规则 |
| `skills/dev/steps/07-quality.md` 开头 | ❌ 没有"Step 7 开始时调用 /ralph-loop"的指令 |
| `skills/dev/steps/09-ci.md` 开头 | ❌ 没有"Step 9 开始时调用 /ralph-loop"的指令 |
| `~/.claude/CLAUDE.md` | ❌ 缺少全局的 Ralph Loop 调用规则 |

### 🔴 矛盾分类 4：Stop Hook 的混乱信号

| 文件位置 | 行号 | 问题 |
|---------|------|------|
| `hooks/stop.sh` | L16 | 注释说"p1: CI pending → exit 0"，但实际代码是 exit 2 |
| `hooks/stop.sh` | L270-282 | p0 阶段输出"p0 阶段结束，不检查 CI" → AI 误以为可以退出 |
| `hooks/stop.sh` | L116,139,164,199,241,296 | 有"Ralph Loop 自动重试机制"提示，但没有说调用 `/ralph-loop` |

### 🔴 矛盾分类 5：SKILL.md 的 Ralph Loop 说明位置错误

| 问题 | 影响 |
|------|------|
| Ralph Loop 说明在第 279 行（中间位置） | AI 看到前面的"结束对话"就停了，没看到后面的 Ralph Loop 说明 |
| 说明是"参考信息"而非"强制指令" | AI 认为 Ralph Loop 是可选的，而非必须的 |
| 没有明确"进入 /dev 必须调用" | AI 不知道什么时候调用 Ralph Loop |

---

## 修复目标

**统一到 Ralph Loop 模式**：
1. ✅ 进入 /dev → 立即调用 `/ralph-loop`
2. ✅ AI 循环检查条件 → 未满足 → 不输出 promise → Ralph Loop 自动继续
3. ✅ AI 循环检查条件 → 全部满足 → 输出 `<promise>SIGNAL</promise>` → Ralph Loop 结束
4. ❌ 删除所有"结束对话"、"允许结束"、"exit 0"等误导性描述
5. ❌ 删除所有 `while true` bash 循环示例

---

## 详细修复方案

### 修复 1: SKILL.md 开头添加强制规则

**位置**：`skills/dev/SKILL.md` L34 之前（在 "⚡ 自动执行规则" 之前）

**添加内容**：

```markdown
## ⚡⚡⚡ Ralph Loop 强制调用（CRITICAL - 最高优先级）

**进入 /dev 后，必须立即调用 Ralph Loop 启动自动循环。**

### 调用时机

```bash
# 1. 检测当前阶段
PHASE=$(bash scripts/detect-phase.sh | grep "^PHASE:" | awk '{print $2}')

# 2. p0 阶段：质检循环
if [[ "$PHASE" == "p0" ]]; then
    /ralph-loop "实现 <PRD 描述的功能>，完成质检并创建 PR 后输出 <promise>QUALITY_GATE_PASSED</promise>" \
        --completion-promise "QUALITY_GATE_PASSED"
fi

# 3. p1 阶段：CI 修复循环
if [[ "$PHASE" == "p1" ]]; then
    PR_NUMBER=$(gh pr list --head $(git rev-parse --abbrev-ref HEAD) --json number -q '.[0].number')
    /ralph-loop "修复 PR #$PR_NUMBER 的 CI 失败，CI 通过并合并后输出 <promise>CI_PASSED</promise>" \
        --completion-promise "CI_PASSED"
fi

# 4. p2/pending/unknown：直接退出（已完成）
```

### Ralph Loop 工作机制

**AI 的职责**：
- ✅ 循环检查完成条件（质检通过？PR 创建？CI 通过？）
- ✅ 条件未满足 → 执行修复步骤 → **不输出 promise** → Ralph Loop 自动继续
- ✅ 条件全部满足 → **输出 `<promise>SIGNAL</promise>`** → Ralph Loop 结束

**禁止行为**：
- ❌ 手动循环检查 CI 状态（手动查 `gh run list`）
- ❌ 自己写 while 循环
- ❌ 修复一次就停下来
- ❌ 等待用户确认
- ❌ 输出"结束对话"、"会话结束"等字眼

**正确行为**：
- ✅ 一次调用 `/ralph-loop`
- ✅ Ralph Loop 自动循环
- ✅ AI 检查条件并决定是否输出 promise
- ✅ 持续运行直到检测到 promise

---

### p0 阶段完成条件检查

**在每次 Ralph Loop 迭代结束时，AI 检查以下条件：**

```
1. Audit 报告存在？(docs/AUDIT-REPORT.md)
   ❌ → 调用 /audit → 不输出 promise → 继续

2. Audit Decision: PASS？
   ❌ → 修复 L1/L2 问题 → 不输出 promise → 继续

3. .quality-gate-passed 存在且有效？
   ❌ → 运行 npm run qa:gate → 不输出 promise → 继续

4. PR 已创建？
   ❌ → 创建 PR (gh pr create) → 不输出 promise → 继续

✅ 全部满足 → 输出 <promise>QUALITY_GATE_PASSED</promise> → Ralph Loop 结束
```

### p1 阶段完成条件检查

**在每次 Ralph Loop 迭代结束时，AI 检查以下条件：**

```
1. 质检仍然有效？（代码修改后需要重新质检）
   ❌ → 运行 npm run qa:gate → 不输出 promise → 继续

2. CI 状态？
   - PENDING/QUEUED/IN_PROGRESS → 不输出 promise → Ralph Loop 继续（轮询）
   - FAILURE → 分析失败 → 修复代码 → push → 不输出 promise → 继续
   - SUCCESS → 继续下一步

3. PR 已合并？
   ❌ → gh pr merge --squash --delete-branch → 不输出 promise → 继续

✅ 全部满足 → 输出 <promise>CI_PASSED</promise> → Ralph Loop 结束
```
```

---

### 修复 2: 删除 SKILL.md 的误导性描述

**位置**：`skills/dev/SKILL.md`

**删除/修改**：

```diff
- ### 唯一停止点
-
- - p0 阶段：PR 创建成功后（Stop Hook 允许结束）
- - p1 阶段：CI 通过且 PR 合并后
- - p2 阶段：检测到 CI 已通过时

+ ### Ralph Loop 结束条件
+
+ - p0 阶段：检查所有条件 → 全部满足 → 输出 <promise>QUALITY_GATE_PASSED</promise>
+ - p1 阶段：检查所有条件 → 全部满足 → 输出 <promise>CI_PASSED</promise>
+ - p2/pending/unknown 阶段：不启动 Ralph Loop，直接退出
```

```diff
│      ↓                                                  │
│  提交 PR (08-pr.md)                                     │
- │      │   Stop Hook: PR 创建后立即结束                   │
- │      │   不检查 CI（p0 不等待 CI）                      │
- │      ↓                                                  │
- │  结束对话 ✅ （不等 CI）                                 │

+ │      ↓                                                  │
+ │  检查 p0 完成条件                                        │
+ │      ├─ 全部满足 → 输出 <promise>QUALITY_GATE_PASSED</promise> │
+ │      └─ Ralph Loop 结束 ✅                              │
```

```diff
│      │         gh pr merge --squash --delete-branch     │
- │      │         break（退出循环）                         │
- │      ↓                                                  │
- │  结束对话 ✅ （PR 已合并）                               │

+ │      │         输出 <promise>CI_PASSED</promise>        │
+ │      └─ Ralph Loop 结束 ✅                              │
```

```diff
- p0: 质检未通过 OR PR 未创建 → exit 2（继续）
- p1: CI fail → exit 2（继续修）
-     CI pending → exit 0（退出，等唤醒）
-     CI pass → exit 0（结束）

+ p0: 条件未满足 → 不输出 promise → Ralph Loop 继续
+ p1: CI fail/pending → 不输出 promise → Ralph Loop 继续
+     CI pass + 合并完成 → 输出 <promise>CI_PASSED</promise> → Ralph Loop 结束
```

---

### 修复 3: Step 8 删除"立即结束对话"

**位置**：`skills/dev/steps/08-pr.md`

**删除/修改**：

```diff
# Step 8: 提交 PR

- > 版本号 + commit + push + PR
- > **p0 阶段在此结束：PR 创建后立即结束对话，不等待 CI**

+ > 版本号 + commit + push + PR
+ > **p0 阶段：PR 创建后检查完成条件，满足则 Ralph Loop 结束**
```

```diff
- **Stop Hook 行为**：
-
- - PR 创建后，Stop Hook 检测到 PHASE=p0
- - 质检已通过 + PR 已创建
- - 不检查 CI 状态（p0 不等待 CI）
- - Stop Hook 返回 `exit 0`，允许会话结束

+ **Ralph Loop 完成条件检查**：
+
+ PR 创建后，AI 检查所有 p0 条件：
+ - ✅ Audit Decision: PASS
+ - ✅ .quality-gate-passed 存在
+ - ✅ PR 已创建
+
+ 全部满足 → 输出 <promise>QUALITY_GATE_PASSED</promise> → Ralph Loop 结束
```

---

### 修复 4: Step 9 改成 Ralph Loop 调用

**位置**：`skills/dev/steps/09-ci.md`

**完全重写前 100 行**：

```markdown
# Step 9: CI 修复（p1 阶段）

> **p1 阶段由 Ralph Loop 控制循环，持续检查 CI 直到成功并合并**

---

## ⚡ Ralph Loop 启动（进入 Step 9 第一件事）

**检测到 p1 阶段后，立即调用 Ralph Loop：**

```bash
# 获取 PR 编号
PR_NUMBER=$(gh pr list --head $(git rev-parse --abbrev-ref HEAD) --json number -q '.[0].number')

if [[ -z "$PR_NUMBER" ]]; then
    echo "❌ 错误：未找到 PR"
    exit 1
fi

# 调用 Ralph Loop 启动 CI 修复循环
/ralph-loop "修复 PR #$PR_NUMBER 的 CI 失败，CI 通过并合并后输出 <promise>CI_PASSED</promise>" \
    --completion-promise "CI_PASSED"
```

**Ralph Loop 会自动循环，直到检测到 `<promise>CI_PASSED</promise>` 才结束。**

---

## AI 在 Ralph Loop 中的职责

### 每次迭代检查以下条件：

#### 1. 质检有效性检查

代码修改后，质检可能过期：

```bash
# 检查 .quality-gate-passed 是否比最新代码修改更新
if [[ 质检文件过期 ]]; then
    npm run qa:gate
    # 不输出 promise，Ralph Loop 继续
fi
```

#### 2. CI 状态检查

```bash
CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state,conclusion -q '.[0]')

case "$CI_STATUS":
    PENDING/QUEUED/IN_PROGRESS:
        # CI 运行中，等待
        # 不输出 promise，Ralph Loop 继续（轮询效果）

    FAILURE:
        # 分析失败原因
        gh run view <id> --log-failed

        # 修复代码
        # ... 修复逻辑 ...

        # 提交并 push
        git add -A
        git commit -m "fix: CI 失败修复"
        git push origin HEAD

        # 不输出 promise，Ralph Loop 继续

    SUCCESS:
        # 继续下一步（合并检查）
```

#### 3. PR 合并检查

```bash
# 合并 PR
gh pr merge "$PR_NUMBER" --squash --delete-branch

# 全部完成 → 输出 promise
echo "<promise>CI_PASSED</promise>"
# Ralph Loop 检测到 promise → 结束循环 ✅
```

---

## 禁止行为

- ❌ 自己写 `while true` 循环
- ❌ 手动查询 CI 状态后就停止
- ❌ 修复一次就退出
- ❌ 输出"结束对话"、"等待外部唤醒"

## 正确行为

- ✅ Ralph Loop 自动循环
- ✅ AI 检查条件并执行修复
- ✅ 条件未满足 → 不输出 promise → 继续
- ✅ 条件全部满足 → 输出 promise → 结束

---
```

**删除原有的**：
- L59-86：Stop Hook 行为（p1）
- L90-198：轮询循环实现（while true）
- L205-243：事件驱动 vs 轮询循环对比

---

### 修复 5: 删除 09.5-pending-wait.md

**原因**：
- 这个文件用 `while true` bash 循环示例，会误导 AI
- Ralph Loop 模式下不需要这个文件

**操作**：
```bash
git rm skills/dev/steps/09.5-pending-wait.md
```

或者改名：
```bash
git mv skills/dev/steps/09.5-pending-wait.md skills/dev/steps/.archive/09.5-pending-wait-deprecated.md
```

---

### 修复 6: CLAUDE.md 添加全局规则

**位置**：`~/.claude/CLAUDE.md` （在 "AI Thinking 规则" 之后）

**添加内容**：

```markdown
---

## Ralph Loop 自动调用规则（CRITICAL）

**遇到以下场景时，必须调用 /ralph-loop，禁止手动循环。**

### 触发场景

#### 1. 进入 /dev 流程（p0 阶段）

```bash
/ralph-loop "实现<功能描述>，完成质检并创建 PR 后输出 <promise>QUALITY_GATE_PASSED</promise>" \
    --completion-promise "QUALITY_GATE_PASSED"
```

**AI 职责**：
- 循环检查：Audit PASS？质检通过？PR 创建？
- 条件未满足 → 修复 → 不输出 promise → Ralph Loop 继续
- 条件全部满足 → 输出 `<promise>QUALITY_GATE_PASSED</promise>` → 结束

#### 2. 检测到 p1 阶段（CI fail）

```bash
/ralph-loop "修复 PR #<number> 的 CI 失败，CI 通过并合并后输出 <promise>CI_PASSED</promise>" \
    --completion-promise "CI_PASSED"
```

**AI 职责**：
- 循环检查：质检有效？CI 状态？PR 合并？
- CI pending → 不输出 promise → Ralph Loop 继续（轮询）
- CI failure → 修复 → push → 不输出 promise → 继续
- CI success + 合并完成 → 输出 `<promise>CI_PASSED</promise>` → 结束

#### 3. 用户说"继续修复"且 PR 存在

- 检测当前阶段（`bash scripts/detect-phase.sh`）
- p1 → 调用 Ralph Loop (CI 修复)
- p0 → 调用 Ralph Loop (质检循环)

### 禁止行为（CRITICAL）

- ❌ 手动循环检查 CI 状态（手动查 `gh run list`）
- ❌ 修复一次就停下来
- ❌ 自己写 `while true` 循环
- ❌ 输出"结束对话"、"会话结束"、"等待用户确认"
- ❌ 看到 "exit 0"、"允许结束" 就停下来

### 正确行为（CRITICAL）

- ✅ 一次调用 `/ralph-loop`
- ✅ Ralph Loop 自动循环
- ✅ AI 检查条件并决定是否输出 promise
- ✅ 持续运行直到检测到 promise
- ✅ 条件未满足时，执行修复后**不输出 promise**，让 Ralph Loop 继续

---
```

---

### 修复 7: 修复 hooks/stop.sh 的注释

**位置**：`hooks/stop.sh`

**修改**：

```diff
# ============================================================================
# Stop Hook: 质检门控（两阶段分离）
# ============================================================================
# 根据当前阶段（p0/p1/p2/pending）决定检查什么：
#
# p0 (Published 阶段):
#   - 检查质检（Step 7）
#   - 检查 PR 创建（Step 8）
-   - 不检查 CI（创建 PR 后立即结束，不等 CI）
+   - 不检查 CI（创建 PR 后 Ralph Loop 检查完成条件）
#
# p1 (CI fail 阶段):
#   - 检查质检（Step 7）
#   - 检查 PR 存在（Step 8）
-   - 检查 CI 状态（Step 9）
-   - CI fail → exit 2（继续修）
-   - CI pending → exit 0（退出，等下次唤醒）
-   - CI pass → exit 0（结束）
+   - 阻止会话结束，强制调用 /dev（Ralph Loop 会处理 CI）
#
# p2/pending:
#   - 直接允许结束（exit 0）
# ============================================================================
```

```diff
    if [[ "$PHASE" == "p0" ]]; then
        # p0 阶段：PR 创建后立即结束，不检查 CI
        echo "  📌 当前阶段: p0 (Published)" >&2
-       echo "  ✅ PR 创建完成，p0 阶段结束" >&2
+       echo "  ✅ PR 创建完成，检查 Ralph Loop 完成条件" >&2
        echo "" >&2
-       echo "  不检查 CI（p0 不等待 CI，直接结束）" >&2
+       echo "  不检查 CI（p0 阶段到此为止）" >&2
        echo "" >&2
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
-       echo "  ✅ p0 任务完成" >&2
+       echo "  ✅ p0 检查完成（Ralph Loop 会检查完成条件）" >&2
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
        echo "" >&2
        echo "  完成步骤:" >&2
        echo "    ✅ Step 7: 质检通过（Audit + 测试）" >&2
        echo "    ✅ Step 8: PR 创建完成 (#$PR_NUMBER)" >&2
        echo "" >&2
-       echo "  后续: CI 自动运行，下次启动检测 CI 结果（p1/p2）" >&2
+       echo "  Ralph Loop: 检查所有条件是否满足" >&2
        echo "" >&2
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2

-       # exit 0: p0 阶段结束，允许会话结束
+       # exit 0: p0 检查完成，Ralph Loop 会检查完成条件并决定是否结束
        exit 0
```

---

### 修复 8: Step 7 开头添加 Ralph Loop 提示

**位置**：`skills/dev/steps/07-quality.md` L1-6

**修改**：

```diff
# Step 7: 质检

> Audit Node 做代码审计，然后跑测试
- > **Stop Hook 强制执行：p0 阶段必须完成质检才能创建 PR**

+ > **Ralph Loop 循环执行：质检失败时自动修复并重试**
+ > **Stop Hook 检查：质检未通过时阻止退出（exit 2）**
+ >
+ > **注意**：Step 7 由 Ralph Loop 控制循环，AI 不需要手动循环检查
```

---

## 验收标准

### DoD

- [ ] SKILL.md 开头添加 Ralph Loop 强制调用规则
- [ ] SKILL.md 删除所有"结束对话"、"允许结束"描述
- [ ] SKILL.md 修改流程图，删除"结束对话"节点
- [ ] Step 8 删除"立即结束对话，不等待 CI"
- [ ] Step 8 修改为 Ralph Loop 完成条件检查
- [ ] Step 9 完全重写，改为 Ralph Loop 启动指令
- [ ] Step 9 删除所有 `while true` bash 循环示例
- [ ] 删除或归档 09.5-pending-wait.md
- [ ] CLAUDE.md 添加 Ralph Loop 全局调用规则
- [ ] hooks/stop.sh 修复注释（删除"exit 0 退出等唤醒"）
- [ ] hooks/stop.sh 修改 p0 阶段的输出信息
- [ ] Step 7 开头添加 Ralph Loop 循环提示
- [ ] 所有文档统一到 Ralph Loop 模式（无"事件驱动"描述）

### 测试验证

- [ ] 端到端测试：/dev → Ralph Loop 自动循环 → PR 创建 → promise 输出 → 结束
- [ ] p1 阶段测试：CI fail → Ralph Loop 自动循环 → 修复 → CI pass → 合并 → promise → 结束
- [ ] 中途接管测试：用户说"继续修复" → 检测 p1 → 调用 Ralph Loop → 自动循环到完成

---

## 关键改动总结

### 删除的概念
- ❌ "结束对话"、"会话结束"
- ❌ "允许结束"、"直接结束"
- ❌ "exit 0 退出，等外部唤醒"
- ❌ `while true` bash 循环
- ❌ "事件驱动修复"

### 添加的概念
- ✅ Ralph Loop 强制调用（进入 /dev 第一步）
- ✅ 完成条件检查（每次迭代检查）
- ✅ promise 输出控制（满足条件才输出）
- ✅ 自动循环直到完成

### 核心原则
1. **AI 不能停**：只有 Ralph Loop 检测到 promise 才能停
2. **一次调用**：进入 /dev 调用一次 /ralph-loop，之后自动循环
3. **条件检查**：AI 循环检查完成条件，决定是否输出 promise
4. **无手动循环**：禁止 AI 自己写 while 循环或手动查 CI

---

## 优先级

**P0 - CRITICAL**

**原因**：
- 当前 AI 会手动循环，浪费大量 token 和时间
- 用户体验极差（需要手动监督 AI 修复 4 次）
- Ralph Loop 是核心机制，必须正确工作

---

## 相关文档

- `docs/RALPH-LOOP-INTERCEPTION.md` - Ralph Loop 拦截逻辑说明
- `hooks/stop.sh` - Stop Hook 实现
- `scripts/detect-phase.sh` - 阶段检测脚本
