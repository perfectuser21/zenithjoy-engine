---
id: hook-enforcement-strategy
version: 1.0.0
created: 2026-01-24
updated: 2026-01-24
changelog:
  - 1.0.0: Hook 强制能力综合分析 + 工作流调整方案
---

# Hook 强制能力与工作流调整策略

**目的**: 基于官方 Hook 文档，明确哪些能强制、哪些不能，并提供现实可行的工作流调整方案。

---

## 官方 Hook 能力总结

### PreToolUse Hook

```
时机: 工具执行之前
能力: ✅ 可以阻止工具执行
机制: exit 2 → Claude 收到错误，工具不执行
限制: 只对"唯一路径"有效
```

**示例**:
```bash
# hooks/branch-protect.sh (PreToolUse: Write|Edit)
if [[ "$CURRENT_BRANCH" == "main" ]]; then
    echo "❌ 禁止在 main 分支写代码"
    exit 2  # ← 工具被阻止，Claude 无法写代码
fi
```

### PostToolUse Hook

```
时机: 工具执行之后
能力: ❌ 无法阻止或撤销操作
机制: 只能提供反馈给 Claude
限制: 工具已执行完成，文件已修改
```

**示例**:
```bash
# 假设的 hooks/post-write-check.sh (PostToolUse: Write)
FILE_PATH="$1"

# 检查代码质量
if ! eslint "$FILE_PATH"; then
    echo "❌ 代码质量不通过，请修复"
    echo "建议运行: git restore $FILE_PATH"
    exit 2  # ← 这个 exit 只是警告，不能阻止或撤销！
fi
```

**PostToolUse 的实际用途**:
- ✅ 日志记录
- ✅ 通知发送
- ✅ 统计信息
- ✅ 提示 Claude 注意问题
- ❌ **不能**: 强制撤销、阻止错误操作、强制质检

### 官方文档关键点

| Hook 类型 | 触发时机 | 阻止能力 | 撤销能力 |
|----------|---------|---------|---------|
| PreToolUse | 工具执行前 | ✅ 能 (exit 2) | N/A |
| PostToolUse | 工具执行后 | ❌ 不能 | ❌ 不能 |

**Exit Code 语义**:
- `exit 0`: 成功
- `exit 2`: 阻塞错误（PreToolUse 能阻止工具，PostToolUse 只是警告）
- `exit 1, 3+`: 非阻塞错误

---

## /dev 工作流 11 步防护能力矩阵

基于官方 Hook 能力，重新评估每一步：

| 步骤 | 操作 | Hook 类型 | 能否 100% 强制 | 原因 |
|------|------|----------|---------------|------|
| 1. PRD 确定 | Write (.prd.md) | PreToolUse | ✅ **能** | 唯一路径 |
| 2. 环境检测 | Bash (git status) | - | ❌ 不能 | AI 可跳过 |
| 3. 分支创建 | Bash (git checkout) | - | ❌ 不能 | AI 可跳过 |
| 4. DoD 定稿 | Write (.dod.md) | PreToolUse | ✅ **能** | 唯一路径 |
| 5. 写代码 | Write/Edit | PreToolUse | ✅ **能** (限分支/PRD/DoD) | 唯一路径 |
| 6. 写测试 | Write/Edit | PreToolUse | ❌ **不能** | Hook 无法区分测试文件 |
| 7. 质检 | Bash (npm run qa) | - | ❌ **不能** | 多路径 + AI 自觉 |
| 8. 提交 PR | Bash (gh pr create) | PreToolUse | ⚠️ 部分能 (60%) | 多路径 |
| 9. CI 运行 | GitHub Actions | - | ✅ **能 (100%)** | 服务器端 |
| 10. 人工审核 | GitHub Web | - | ✅ **能 (100%)** | A+ 强制 |
| 11. 合并 | GitHub | - | ✅ **能 (100%)** | A+ 强制 |

### 详细说明

#### ✅ 能 100% 强制的步骤

**Step 1, 4, 5: 写代码阶段**
```
AI 写代码/PRD/DoD
    ↓
必须使用 Write/Edit 工具（唯一路径）
    ↓
PreToolUse: branch-protect.sh 拦截
    ↓
检查: 分支 + PRD/DoD 存在 + 内容有效
    ↓
不通过 → exit 2 → 工具被阻止
    ↓
AI 无法绕过（没有其他方式写文件）
```

**Step 9, 10, 11: CI + A+ 阶段**
```
服务器端强制执行
    ↓
GitHub Actions 运行测试
    ↓
Branch Protection 要求 CI 绿 + 人工审核
    ↓
AI 无法绕过（在 GitHub 服务器端）
```

#### ❌ 不能 100% 强制的步骤

**Step 6: 写测试**
```
问题: Hook 无法判断是否写了测试
    ├─ Hook 只能拦截 Write/Edit 工具
    ├─ 但无法区分是代码文件还是测试文件
    ├─ 无法检查测试覆盖率
    └─ 无法检查测试质量

依赖:
    ├─ DoD 中列出测试要求（但 AI 可不勾选）
    └─ CI 运行测试覆盖率检查（100% 有效）
```

**Step 7: 质检**
```
问题: AI 可以跳过或忽略结果
    ├─ npm run qa 是 Bash 命令（多路径）
    ├─ AI 可以不运行
    ├─ AI 可以运行但判断"已有问题，不修复"
    └─ Hook 无法强制

尝试方案:
    ├─ PostToolUse 提示? → 无效（只是警告）
    ├─ 质检门控文件? → 无效（AI 可以伪造）
    └─ 依赖 CI → 有效（100%）
```

**Step 8: 提交 PR**
```
问题: AI 有多种方式创建 PR
    ├─ gh pr create → Hook 拦截 ✅
    ├─ gh api POST → Hook 拦截 ✅（修复后）
    ├─ curl POST → Hook 拦截 ✅（修复后）
    ├─ Python requests → Hook 无法拦截 ❌
    ├─ Node.js fetch → Hook 无法拦截 ❌
    └─ 其他语言 → Hook 无法拦截 ❌

当前防护: 60%（拦截明显方式）
最终防护: CI + A+（100%）
```

---

## 核心洞察："唯一路径" 是 100% 强制的前提

### 能防住的场景

```
写代码权限控制:
    AI 想写代码
        ↓
    唯一方式: Write/Edit 工具
        ↓
    PreToolUse Hook 拦截
        ↓
    检查不通过 → exit 2
        ↓
    AI 无法写代码 ✅
```

### 防不住的场景

```
质检执行控制:
    AI 想跳过质检
        ↓
    方式 1: 不运行 npm run qa
    方式 2: 运行但忽略失败
    方式 3: 判断"理由正当"
        ↓
    Hook 无法拦截所有路径 ❌
        ↓
    依赖 CI 强制执行 ✅
```

---

## 三个调整方案

### 方案 A: 接受现实，分层防护（推荐）

**核心思想**: Hook 做能做的，CI + A+ 做最终防线

```
┌─────────────────────────────────────────┐
│  Layer 1: Hook (60% - 快速失败)         │
│  ✅ 防止在错误分支写代码                 │
│  ✅ 防止没有 PRD/DoD                     │
│  ❌ 不强制质检（AI 自觉）                │
│  ❌ 不强制写测试（AI 自觉）              │
└─────────────────────────────────────────┘
            ↓ (AI 可能跳过质检)
┌─────────────────────────────────────────┐
│  Layer 2: CI (100% - 真正门控)          │
│  ✅ 强制运行所有测试                     │
│  ✅ 强制代码质量检查                     │
│  ✅ 无法绕过                             │
└─────────────────────────────────────────┘
            ↓ (只有 CI 绿才能继续)
┌─────────────────────────────────────────┐
│  Layer 3: A+ (100% - 人工门控)          │
│  ✅ CI 绿才能合并                        │
│  ✅ 必须人工审核                         │
│  ✅ 最后防线                             │
└─────────────────────────────────────────┘
```

**优点**:
- ✅ 现实可行
- ✅ CI + A+ 提供 100% 保护
- ✅ Hook 作为"快速失败"机制，减少 CI 消耗
- ✅ 开发体验不受影响

**缺点**:
- ❌ AI 可能创建失败的 PR（浪费 CI 配额）
- ❌ 需要等 CI 才知道问题

**调整点**:
- 保持 branch-protect.sh 当前逻辑（分支 + PRD/DoD）
- pr-gate-v2.sh 已在 v12.5.4 删除（质检交给 CI）
- **不添加新的 Hook** - 承认局限性
- 依赖 CI 作为真正的质检门控

---

### 方案 B: 质检门控前置（最强，但复杂）

**核心思想**: 在 PreToolUse:Write 中检查质检状态文件

```bash
# hooks/branch-protect.sh 添加质检检查

# 检查是否通过质检
if [[ ! -f "$PROJECT_ROOT/.quality-gate-passed" ]]; then
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  ❌ 质检未通过"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "请先运行质检:"
    echo "  npm run qa"
    echo ""
    echo "所有测试通过后会生成 .quality-gate-passed 文件"
    exit 2
fi

# 检查质检文件时间戳（确保是最新的）
CODE_MTIME=$(find src tests -type f -name "*.ts" -printf "%T@\n" | sort -n | tail -1)
GATE_MTIME=$(stat -c %Y .quality-gate-passed)

if (( $(echo "$CODE_MTIME > $GATE_MTIME" | bc -l) )); then
    echo "❌ 代码已修改，质检结果过期"
    echo "请重新运行: npm run qa"
    exit 2
fi
```

**工作流**:
```
1. 写一些代码
2. 想继续写代码 → branch-protect 拦截
3. 提示: 请先运行 npm run qa
4. 运行 npm run qa
   ├─ 通过 → 生成 .quality-gate-passed
   └─ 失败 → 修复 → 重新运行
5. 继续写代码（允许）
6. 修改代码后 → 质检文件过期 → 再次拦截
```

**优点**:
- ✅ 100% 强制质检（唯一路径）
- ✅ 无法绕过
- ✅ 本地早期发现问题

**缺点**:
- ❌ 工作流复杂（每次写代码前要质检）
- ❌ 开发体验差（频繁被打断）
- ❌ AI 可以伪造 `.quality-gate-passed` 文件
  - 解决: 文件包含加密签名？过于复杂
- ❌ 时间戳检查有漏洞（AI 可以 touch 文件）

**评估**: 理论上可行，但实际上：
1. AI 可以伪造质检文件
2. 开发体验显著下降
3. 增加 Hook 复杂度
4. 最终还是依赖 CI

---

### 方案 C: PostToolUse 提示 + AI 自律（最弱）

**核心思想**: 用 PostToolUse 提示 AI，依赖 AI 自觉

```bash
# hooks/post-code-check.sh (PostToolUse: Write|Edit)

# 文件已写入，运行质检
npm run qa

if [ $? -ne 0 ]; then
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  ⚠️  质检失败！"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "根据 /dev 工作流，你应该："
    echo "1. 修复失败的测试"
    echo "2. 重新运行 npm run qa"
    echo "3. 确保全部通过后再继续"
    echo ""
    echo "如果这是已有问题，请先修复再提交你的代码"
    exit 2  # ← 这只是警告，不能强制
fi
```

**优点**:
- ✅ 实现简单
- ✅ 不影响开发体验

**缺点**:
- ❌ AI 可以忽略提示
- ❌ 完全依赖 AI 自觉
- ❌ 防护能力 ~0%

**评估**: 几乎没有强制能力

---

## 推荐方案：A（分层防护）

### 为什么选择方案 A？

| 标准 | 方案 A | 方案 B | 方案 C |
|------|--------|--------|--------|
| **防护能力** | ⭐⭐⭐⭐⭐ (CI 100%) | ⭐⭐⭐⭐ (可绕过) | ⭐ (几乎无) |
| **开发体验** | ⭐⭐⭐⭐⭐ (不打断) | ⭐⭐ (频繁打断) | ⭐⭐⭐⭐⭐ |
| **实现复杂度** | ⭐⭐⭐⭐⭐ (现有) | ⭐⭐ (复杂) | ⭐⭐⭐⭐ |
| **可维护性** | ⭐⭐⭐⭐⭐ (简单) | ⭐⭐ (复杂) | ⭐⭐⭐⭐ |

### 核心原则

**唯一路径的用 Hook，多路径的用 CI + A+**

```
┌─────────────────────────────────────────┐
│  Hook 职责（唯一路径 → 100% 有效）       │
├─────────────────────────────────────────┤
│  ✅ 分支保护（写代码权限）               │
│  ✅ PRD/DoD 检查（必要产物）             │
│  ✅ 快速失败（明显的错误命令）           │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  CI 职责（多路径 → 100% 有效）           │
├─────────────────────────────────────────┤
│  ✅ 测试覆盖率                           │
│  ✅ 代码质量                             │
│  ✅ 构建验证                             │
│  ✅ 最终门控                             │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  A+ 职责（服务器端 → 100% 有效）         │
├─────────────────────────────────────────┤
│  ✅ CI 绿才能合并                        │
│  ✅ 人工审核                             │
│  ✅ 最后防线                             │
└─────────────────────────────────────────┘
```

### 实施清单

#### ✅ 保持现有 Hook（已完成）

1. **branch-protect.sh**:
   - ✅ 分支检查（cp-*/feature/* only）
   - ✅ PRD/DoD 存在性检查
   - ✅ PRD/DoD 内容有效性检查
   - ✅ 不添加质检门控

2. **pr-gate-v2.sh** (已删除 v12.5.4):
   - 质检完全交给 CI 处理
   - 本地 Hook 无法 100% 拦截 PR 创建（多路径）

#### ✅ 强化 CI（已完成）

```yaml
# .github/workflows/ci.yml
jobs:
  test:
    - npm run typecheck
    - npm run test
    - npm run build

  devgate:
    - bash scripts/devgate/assert-ci-guards.sh
    - npm run coverage:rci

  release-check: (PR to main 时)
    - bash scripts/release-check.sh
```

#### ✅ 确保 A+ Protection（已完成）

```
Branch: main, develop
├─ require_status_checks: test (CI 必须绿)
├─ required_approving_review_count: 1
├─ restrictions: empty (禁止任何人 push)
└─ enforce_admins: true (Admin 也必须遵守)
```

---

## 调整后的工作流文档

### 更新 WORKFLOW-DEFENSE-MAP.md

```markdown
## 真实的防护地图

┌─────────────────────────────────────────┐
│  本地阶段 (Hook - 60% 快速失败)          │
├─────────────────────────────────────────┤
│  Step 1-5: 写代码     ✅ 100% (唯一路径)│
│  Step 6: 写测试       ❌ 0% (AI 自觉)   │
│  Step 7: 质检         ❌ 0% (AI 自觉)   │
│  Step 8: PR 创建      ⚠️ 60% (多路径)   │
└─────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│  服务器阶段 (CI + A+ - 100% 强制)        │
├─────────────────────────────────────────┤
│  Step 9: CI           ✅ 100%           │
│  Step 10: 人工审核    ✅ 100%           │
│  Step 11: 合并        ✅ 100%           │
└─────────────────────────────────────────┘

关键原则:
- Hook 防护 = 门卫检查入场券（分支、PRD、DoD）
- CI 防护 = 真正的质量门控（测试、质检、构建）
- A+ 防护 = 最后防线（人工审核）
```

### 更新 skills/dev/steps/07-quality.md

```markdown
# Step 7: 质检

## 执行

npm run qa

## Hook 行为

**Hook 不强制质检执行**

原因:
- npm run qa 是 Bash 命令（多路径）
- AI 可以选择跳过或忽略失败
- Hook 无法 100% 防止绕过

## 真正的防护

**依赖 CI (100% 强制)**:
- GitHub Actions 强制运行所有测试
- 失败则无法合并
- AI 无法绕过

## 最佳实践

虽然 Hook 不强制，但 AI 应该：
1. 运行 npm run qa
2. 修复所有失败
3. 确保本地绿再提交 PR

**但最终保证**: CI + A+ (100%)
```

---

## 风险接受声明

### 已知风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| AI 跳过本地质检 | 中 | 低 | CI 会拦截（100%）|
| AI 创建失败的 PR | 中 | 低 | 浪费 CI 配额，但不影响代码质量 |
| AI 用其他语言绕过 pr-gate | 低 | 低 | CI 会拦截（100%）|

### 为什么风险可接受？

**最终防线永远有效**:
```
即使 AI:
- 跳过本地质检
- 绕过 pr-gate Hook
- 创建了 PR

也会被拦住:
- CI 测试失败 → 无法合并
- 没有人工审核 → 无法合并
- A+ 保护 → 100% 有效
```

**所以风险可控！**

---

## 总结

### 能 100% 防住的

| 操作 | 防护层 | 机制 |
|------|-------|------|
| 在 main/develop 写代码 | Hook | 唯一路径 (PreToolUse) |
| 没有 PRD/DoD 写代码 | Hook | 唯一路径 (PreToolUse) |
| 测试失败合并 PR | CI + A+ | 服务器端强制 |
| 未经审核合并 PR | A+ | 服务器端强制 |

### 防不住的（但最终会被拦）

| 操作 | 本地防护 | 最终防护 |
|------|---------|---------|
| AI 跳过质检 | ❌ 0% | ✅ CI (100%) |
| AI 不写测试 | ❌ 0% | ✅ CI (100%) |
| AI 绕过 pr-gate | ⚠️ 60% | ✅ CI (100%) |

### 核心洞察

**Hook 是门卫，不是监工**

```
门卫职责:
✅ 检查入场券（分支、PRD、DoD）
✅ 拦截明显违规（gh pr create）
✅ 快速失败（减少浪费）

监工职责:
❌ 监督工作质量（代码质量）
❌ 检查产出物（测试覆盖率）
❌ 强制执行流程（质检）

→ 监工职责由 CI + A+ 承担（100% 有效）
```

---

## 下一步行动

### 立即执行

1. **接受方案 A** - 分层防护策略
2. **更新文档** - WORKFLOW-DEFENSE-MAP.md 添加风险声明
3. **确认理解** - 团队达成共识：Hook 60%, CI 100%, A+ 100%

### 不需要做的

1. ❌ 不添加 PostToolUse Hook
2. ❌ 不添加质检门控文件
3. ❌ 不追求 Hook 100% 拦截所有 PR 创建方式

### 长期维护

1. **监控 CI 配额** - 如果 AI 频繁创建失败 PR，考虑优化提示
2. **收集数据** - 记录 Hook 拦截率 vs CI 拦截率
3. **定期审核** - 确保 A+ Protection 配置正确

---

*生成时间: 2026-01-24*
*基于: 官方 Hook 文档 + WORKFLOW-DEFENSE-MAP.md + HOOK-DEFENSE-ANALYSIS.md*
