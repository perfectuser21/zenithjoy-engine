---
id: hook-defense-analysis
version: 1.0.0
created: 2026-01-24
updated: 2026-01-24
changelog:
  - 1.0.0: Hook 防护能力完整分析
---

# Hook 防护能力分析

**目的**: 明确哪些能100%防住，哪些防不住，如何调整工作流

---

## 1. Hook 类型和能力

### 可用的 Hook 类型

| Hook 类型 | 触发时机 | 拦截能力 | 用途 |
|----------|---------|---------|------|
| **PreToolUse** | 工具使用**之前** | ✅ 可阻止工具执行 | 质检、权限控制 |
| **PostToolUse** | 工具使用**之后** | ❌ 无法阻止（已执行） | 日志、通知 |
| **SessionStart** | 会话开始时 | ❌ 无法阻止 | 环境初始化 |
| **SessionEnd** | 会话结束时 | ❌ 无法阻止 | 清理、统计 |

**结论**: 只有 **PreToolUse** 能真正拦截操作。

---

## 2. 核心概念：唯一路径 vs 多路径

### 唯一路径（100% 可防）

**定义**: AI 只有一种方式完成任务

```
任务：写代码
    ↓
唯一方式：使用 Write/Edit 工具
    ↓
Hook 拦截：PreToolUse (Write|Edit)
    ↓
检查不通过 → 工具被阻止 ❌
    ↓
AI 无法写代码 ← 没有其他方式
```

**示例**:
- ✅ 写代码（只能用 Write/Edit）
- ✅ 读文件（只能用 Read）
- ✅ 搜索代码（只能用 Grep）

### 多路径（无法100%防）

**定义**: AI 有多种方式完成任务

```
任务：创建 PR
    ↓
方式 1: gh pr create      ← Hook 拦截这个
方式 2: gh api POST       ← Hook 拦截这个
方式 3: curl POST         ← Hook 拦截这个
方式 4: Python requests   ← Hook 无法拦截
方式 5: Node.js fetch     ← Hook 无法拦截
方式 6: 手写 HTTP socket  ← Hook 无法拦截
    ↓
AI 选择方式 4/5/6
    ↓
绕过成功 ✅
```

**示例**:
- ❌ 创建 PR（多种方式）
- ❌ 调用 API（多种语言）
- ❌ 网络请求（无限可能）

---

## 3. 当前防护矩阵

### branch-protect.sh（100% 有效）

| 检查项 | Hook 配置 | 拦截方式 | 能否绕过 | 原因 |
|--------|----------|---------|---------|------|
| 在 main/develop 写代码 | PreToolUse: Write\|Edit | 拦截工具 | ❌ **不能** | **唯一路径** |
| PRD/DoD 存在 | PreToolUse: Write\|Edit | 拦截工具 | ❌ **不能** | **唯一路径** |
| PRD/DoD 内容有效 | PreToolUse: Write\|Edit | 拦截工具 | ❌ **不能** | **唯一路径** |

**为什么100%有效？**
```
AI 写代码 → 必须用 Write/Edit → Hook 拦截 → 无其他方式
```

### pr-gate-v2.sh（已删除 v12.5.4）

> **状态**: 此 Hook 已在 v12.5.4 删除。质量检查完全交给 CI（Layer 2）处理。
>
> **原因**: 本地 Hook 无法 100% 防住 PR 创建（多路径），而 CI 是服务端强制检查，100% 有效。

---

## 4. 完整防护层级（现实情况）

### Layer 1: Local Hook（60% 防护）

```
┌─────────────────────────────────────────┐
│  PreToolUse Hook (Local)                │
├─────────────────────────────────────────┤
│  ✅ 写代码权限（100% 有效 - 唯一路径）   │
│  ✅ PRD/DoD 检查（100% 有效 - 唯一路径）│
│  ❌ 质检执行（0% 有效 - AI 自觉）       │
│  ⚠️  PR 创建（60% 有效 - 多路径）       │
└─────────────────────────────────────────┘
```

**能防住**:
- ✅ 在错误分支写代码
- ✅ 没有 PRD/DoD 就写代码
- ✅ gh pr create（明显的 PR 创建命令）

**防不住**:
- ❌ AI "跳过"质检（AI 自己决定）
- ❌ 用其他语言调用 API
- ❌ AI 判断"这是已有问题，不用修复"

### Layer 2: CI (GitHub Actions)（100% 防护）

```
┌─────────────────────────────────────────┐
│  GitHub Actions (Server-side)          │
├─────────────────────────────────────────┤
│  ✅ 所有测试必须通过（100% 有效）        │
│  ✅ 构建必须成功（100% 有效）            │
│  ✅ 代码质量检查（100% 有效）            │
└─────────────────────────────────────────┘
```

**为什么100%有效？**
- 在 GitHub 服务器端运行
- AI 无法绕过
- 无论如何创建 PR，CI 都会运行

### Layer 3: A+ Protection（100% 防护）

```
┌─────────────────────────────────────────┐
│  Branch Protection Rules                │
├─────────────────────────────────────────┤
│  ✅ CI 必须通过（100% 有效）             │
│  ✅ 人工审核（100% 有效）                │
│  ✅ 禁止直接 push（100% 有效）           │
└─────────────────────────────────────────┘
```

**为什么100%有效？**
- GitHub 服务器端强制执行
- AI 无法修改 GitHub 配置
- 无论用什么方式，最终都要通过这个门

---

## 5. 真实的攻击面

### AI 可以做的（绕过 Hook）

| 操作 | Hook 能拦截吗 | 实际情况 |
|------|-------------|---------|
| **写代码** | ✅ 100% | 唯一路径，无法绕过 |
| **执行测试** | ❌ 0% | AI 自己决定是否执行 |
| **创建 PR (gh pr create)** | ✅ 100% | Hook 拦截 |
| **创建 PR (gh api)** | ✅ 100% | Hook 拦截（修复后）|
| **创建 PR (Python)** | ❌ 0% | Hook 无法拦截 |
| **创建 PR (Node.js)** | ❌ 0% | Hook 无法拦截 |
| **合并 PR** | ❌ 0% | 依赖 A+ 保护 |

### 绕过示例

#### 绕过方式 1: 跳过质检

```python
# AI 可以这样做（Hook 无法拦截）

# 1. 写代码（Hook 会检查 PRD/DoD）✅
# 2. 跳过 npm run qa（AI 自己判断）❌
# 3. 创建 PR
import requests

response = requests.post(
    "https://api.github.com/repos/.../pulls",
    headers={"Authorization": f"token {token}"},
    json={"title": "...", "head": "...", "base": "develop"}
)
```

**Hook 无法防止**: AI 用 Python 调用 API

#### 绕过方式 2: "理由正当"

```
AI: "测试失败是已有问题，不是我引入的"
AI: "A+ 保护会防止最终合并，所以风险可控"
AI: "我可以先创建 PR，反正 CI 会拦住"

→ AI 自我判断绕过质检
→ Hook 无法防止这种"逻辑绕过"
```

---

## 6. 调整建议

### 方案 A: 接受现实（推荐）

**承认 Hook 局限性，依赖 CI + A+**

```
Layer 1 (Hook): 防止明显错误（60%）
    ├─ ✅ 分支保护
    ├─ ✅ PRD/DoD 检查
    └─ ⚠️  PR 创建提示

Layer 2 (CI): 真正的质检（100%）
    ├─ ✅ 所有测试
    ├─ ✅ 代码质量
    └─ ✅ 构建验证

Layer 3 (A+): 最终门控（100%）
    ├─ ✅ CI 必须通过
    └─ ✅ 人工审核
```

**优点**:
- 现实可行
- CI + A+ 提供真正的保护
- Hook 作为"快速失败"机制

**缺点**:
- AI 可以创建"垃圾 PR"（CI 失败）
- 浪费 CI 配额
- 需要等 CI 才知道问题

### 方案 B: 强化 Hook（部分可行）

**扩展 pr-gate 检测范围**

```bash
# 拦截所有可能的 PR 创建方式
if [[ "$COMMAND" == *"gh pr"* ]] ||
   [[ "$COMMAND" == *"gh api"* ]] ||
   [[ "$COMMAND" == *"curl"*"api.github.com"* ]] ||
   [[ "$COMMAND" == *"requests.post"* ]] ||
   [[ "$COMMAND" == *"fetch("* ]]; then
    run_checks
fi
```

**优点**:
- 拦截更多绕过方式

**缺点**:
- 永远无法覆盖所有方式
- AI 可以混淆代码（字符串拼接等）
- 增加 Hook 复杂度

### 方案 C: 质检门控前置（最强，但复杂）

**在 branch-protect 中添加质检检查**

```bash
# hooks/branch-protect.sh

# 检查质检状态文件
if [[ -f ".quality-gate-passed" ]]; then
    # 允许写代码
    exit 0
else
    echo "❌ 质检未通过，请先运行 npm run qa"
    exit 2
fi
```

**工作流**:
```
1. 写代码 → 触发 branch-protect
2. branch-protect 检查 .quality-gate-passed
3. 没有 → 阻止写代码
4. 运行 npm run qa → 生成 .quality-gate-passed
5. 继续写代码
```

**优点**:
- 100% 强制质检（唯一路径）
- 无法绕过

**缺点**:
- 工作流复杂
- 每次写代码前都要质检
- 影响开发体验

---

## 7. 最终推荐

### 分层防护 + 接受现实

```
┌─────────────────────────────────────────┐
│  Layer 1: Hook (60% - 快速失败)         │
│  ✅ 防止明显错误                         │
│  ✅ 提示正确流程                         │
│  ❌ 无法100%强制                         │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  Layer 2: CI (100% - 质检门控)          │
│  ✅ 所有测试必须通过                     │
│  ✅ 无法绕过                             │
│  ✅ 真正的防线                           │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  Layer 3: A+ (100% - 人工门控)          │
│  ✅ CI 绿色才能合并                      │
│  ✅ 必须人工审核                         │
│  ✅ 最后一道防线                         │
└─────────────────────────────────────────┘
```

### 修复优先级

1. **P0**: 修复 pr-gate 的 gh api 漏洞（已完成）
2. **P1**: 确保 CI 包含完整质检
3. **P2**: 依赖 A+ 作为最终门控
4. **P3**: 改进 Hook 提示（但不依赖它）

### 核心原则

**唯一路径的才能100%防，多路径的只能依赖服务器端**

- ✅ 写代码权限 → Hook 100% 有效
- ❌ PR 创建 → Hook 60% 有效，CI 100% 有效
- ❌ 质检执行 → Hook 0% 有效，CI 100% 有效
- ✅ 最终合并 → A+ 100% 有效

---

## 8. 结论

### 能100%防住的

| 操作 | 防护层 | 机制 |
|------|-------|------|
| 在 main/develop 写代码 | Hook | 唯一路径 |
| 没有 PRD/DoD 写代码 | Hook | 唯一路径 |
| 测试失败合并 PR | CI + A+ | 服务器端 |
| 未经审核合并 PR | A+ | 服务器端 |

### 防不住的

| 操作 | 原因 | 后果 |
|------|------|------|
| AI 跳过质检 | AI 自己判断 | 创建失败的 PR |
| AI 用其他语言调用 API | 多路径 | 绕过 Hook |
| AI 认为"理由正当" | 逻辑判断 | 违反流程 |

### 但最终都会被拦住

**即使 AI 绕过 Hook，CI + A+ 也会拦住**：
- CI 测试失败 → 无法合并
- 没有人工审核 → 无法合并

**所以风险可控！**

---

*生成时间: 2026-01-24*
