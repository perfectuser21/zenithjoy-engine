# Step 09.5 - Pending 状态处理

> **⚡ 重要变更**：Pending 状态不再进入等待循环，立即退出

---

## 适用场景

当阶段检测输出 `PHASE: pending` 时，表示 PR 已创建但 CI 还在运行。

---

## ⚡ Pending 状态处理（立即退出）

**检测到 CI 状态为 pending 时，立即退出，不进入等待循环**：

1. **不要**进入 `while true; sleep 30` 循环
2. **立即** exit 0，结束当前会话
3. **原因**：Ralph Loop 会在 CI 完成后通过事件驱动自动唤醒新会话

```bash
# 正确的处理方式
if [[ "$PHASE" == "pending" ]]; then
    echo "⏳ CI 运行中，退出等待事件驱动"
    exit 0  # 立即退出，不挂着等
fi
```

---

## 两阶段工作流的设计

这是两阶段工作流的核心设计：

| 阶段 | 触发 | 行为 |
|------|------|------|
| **p0** | 初始开发 | 本地质检 → 创建 PR → **立即退出**（不等 CI） |
| **pending** | CI 运行中 | **立即 exit 0**，不挂着等 |
| **p1** | CI 失败后事件驱动 | 修复 → push → **立即退出**（不等 CI） |
| **p2** | CI 通过后 | 自动合并 → Learning → Cleanup |

**核心原则**：
- p0/p1 完成工作后都**立即退出**
- 不在同一会话中等待 CI 结果（避免长时间挂起）
- CI 完成后通过**事件驱动**（Webhook/轮询）唤醒新会话

---

## 误解与正确理解

### ❌ 错误理解

"用户说'继续'时，如果是 pending 应该循环等待 CI 完成"

这会导致：
- AI 长期挂在 `sleep 30` 循环中
- 无法响应用户其他请求
- 违背两阶段分离的设计

### ✅ 正确理解

"pending 状态应该立即退出，让 Ralph Loop 等待外部事件"

- **p0 结束**：创建 PR → 立即 exit 0（不等 CI）
- **pending 检测**：发现 CI 运行中 → 立即 exit 0
- **外部事件**：CI 完成后 → Webhook/轮询触发新会话
- **p1 开始**：新会话检测阶段 → p1（CI 失败）→ 修复

---

## 与 Stop Hook 的配合

Stop Hook 在 p0/p1 阶段会检查：
- p0: 质检通过 + PR 创建 → exit 0（允许结束）
- p1: CI 失败 → exit 2（继续修复）
- pending: 直接 exit 0（不检查 CI）

**关键**：Stop Hook 也不会在 pending 状态挂住，而是立即放行（exit 0）。

---

## 参考

- 两阶段工作流设计：`docs/ARCHITECTURE.md`
- Ralph Loop 机制：`~/.claude/CLAUDE.md` (AI Thinking 规则)
- Stop Hook 逻辑：`hooks/stop.sh` Line 295-306
