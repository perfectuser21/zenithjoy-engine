# Step 9: CI 修复（p1 阶段）

> p1 阶段：轮询循环，持续检查 CI 直到成功
> **在 P1 阶段执行完整的 while 循环，失败则修复并继续，成功则合并**

---

## 阶段定义

**p1 阶段触发条件**：
- PR 已创建
- CI 状态为 FAILURE

**p1 阶段目标**：
- 持续轮询 CI 状态
- 失败则修复并继续循环（不退出）
- 成功则自动合并并退出

---

## p1 轮询循环

```
┌─────────────────────────────────────────────────────┐
│            p1: CI fail 修复（轮询循环）              │
├─────────────────────────────────────────────────────┤
│                                                     │
│  阶段检测 (scripts/detect-phase.sh)                 │
│      → PHASE: p1                                    │
│      ↓                                              │
│  CI 轮询循环 (09-ci.md)                             │
│      │                                              │
│      │   while true; do                             │
│      │     检查 CI 状态                             │
│      │                                              │
│      │     case:                                    │
│      │       in_progress/queued/pending:            │
│      │         sleep 30s                            │
│      │         continue（继续循环）                 │
│      │                                              │
│      │       failure:                               │
│      │         分析失败原因                          │
│      │         修复代码                             │
│      │         git add && commit && push            │
│      │         continue（继续循环，不退出！）        │
│      │                                              │
│      │       success:                               │
│      │         gh pr merge --squash --delete-branch │
│      │         break（退出循环）                     │
│      │   done                                       │
│      ↓                                              │
│  结束对话 ✅ （GitHub 自动 merge）                   │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## Stop Hook 行为（p1）

**检查逻辑**：

```bash
# 1. 检测阶段
PHASE=$(bash scripts/detect-phase.sh | grep "^PHASE:" | awk '{print $2}')

# 2. p1 阶段检查 CI 状态
if [[ "$PHASE" == "p1" ]]; then
    CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state -q '.[].state' | head -1)

    if [[ "$CI_STATUS" == "PENDING" ]]; then
        # CI pending: 退出，等下次唤醒
        exit 0

    elif echo "$CI_STATUS" | grep -qi "FAILURE"; then
        # CI fail: 阻止结束，继续修复
        echo "CI 失败，需要修复"
        echo "运行: gh pr checks $PR_NUMBER"
        exit 2  # 阻止会话结束

    elif echo "$CI_STATUS" | grep -qi "SUCCESS"; then
        # CI pass: 允许结束
        exit 0
    fi
fi
```

---

## 轮询循环实现

**完整轮询逻辑**：

```bash
# 获取 PR 编号
PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number -q '.[0].number')

# 超时保护（1小时）
TIMEOUT=3600
START_TIME=$(date +%s)

while true; do
    # 检查超时
    CURRENT_TIME=$(date +%s)
    ELAPSED=$((CURRENT_TIME - START_TIME))
    if [ $ELAPSED -gt $TIMEOUT ]; then
        echo "⏱️ 超时保护：轮询超过 1 小时，退出"
        break
    fi

    # 获取 CI 状态
    CI_DATA=$(gh pr checks "$PR_NUMBER" --json state,conclusion,name 2>/dev/null)

    if [ -z "$CI_DATA" ]; then
        echo "⏳ CI 尚未开始，等待 30 秒..."
        sleep 30
        continue
    fi

    # 解析状态
    CI_STATE=$(echo "$CI_DATA" | jq -r '.[0].state')
    CI_CONCLUSION=$(echo "$CI_DATA" | jq -r '.[0].conclusion')

    echo "📊 CI 状态: state=$CI_STATE, conclusion=$CI_CONCLUSION"

    # 状态判断
    case "$CI_STATE" in
        "PENDING"|"QUEUED"|"IN_PROGRESS")
            echo "⏳ CI 运行中，等待 30 秒..."
            sleep 30
            continue
            ;;

        "COMPLETED")
            case "$CI_CONCLUSION" in
                "SUCCESS")
                    echo "✅ CI 通过，自动合并 PR"
                    gh pr merge "$PR_NUMBER" --squash --delete-branch
                    echo "✅ PR 已合并"
                    break
                    ;;

                "FAILURE")
                    echo "❌ CI 失败，开始修复"

                    # 获取失败详情
                    gh pr checks "$PR_NUMBER" --json name,conclusion,detailsUrl

                    # 分析失败原因并修复
                    FAILED_CHECK=$(echo "$CI_DATA" | jq -r '.[] | select(.conclusion == "FAILURE") | .name' | head -1)

                    echo "🔧 修复失败的检查: $FAILED_CHECK"

                    # 根据失败类型修复
                    if echo "$FAILED_CHECK" | grep -qi "typecheck"; then
                        echo "修复类型检查错误..."
                        # 运行 typecheck 查看错误
                        npm run typecheck 2>&1 || true
                        # 修复代码...
                    elif echo "$FAILED_CHECK" | grep -qi "test"; then
                        echo "修复测试失败..."
                        # 运行测试查看错误
                        npm run test 2>&1 || true
                        # 修复代码...
                    elif echo "$FAILED_CHECK" | grep -qi "build"; then
                        echo "修复构建失败..."
                        # 运行构建查看错误
                        npm run build 2>&1 || true
                        # 修复代码...
                    fi

                    # 提交修复
                    git add -A
                    git commit -m "fix: 修复 CI 失败 ($FAILED_CHECK)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
                    /usr/bin/git push origin HEAD

                    echo "✅ 修复已推送，继续循环..."
                    # continue 继续循环，不退出！
                    continue
                    ;;

                *)
                    echo "⚠️ CI 状态异常: $CI_CONCLUSION"
                    sleep 30
                    continue
                    ;;
            esac
            ;;

        *)
            echo "⚠️ 未知 CI 状态: $CI_STATE"
            sleep 30
            continue
            ;;
    esac
done

echo "✅ P1 阶段完成"
```

---

## 事件驱动 vs 轮询循环

**❌ 旧模式（事件驱动）**：
```bash
# 1. 修复代码
fix_code()

# 2. push 触发 CI
git push

# 3. 退出对话（不等 CI）
# Stop Hook: CI pending → exit 0

# 4. 等待外部唤醒
#    - CI fail 通知 → PHASE_OVERRIDE=p1 启动新会话
```

**✅ 新模式（轮询循环）**：
```bash
while true; do
    CI_STATUS=$(gh pr checks "$PR_NUMBER")

    case "$CI_STATUS" in
        running)
            sleep 30
            continue  # 继续循环
            ;;
        failure)
            fix_code
            git push
            continue  # 继续循环（不退出！）
            ;;
        success)
            gh pr merge
            break  # 退出循环
            ;;
    esac
done
```

---

## CI 失败详情获取

```bash
# 获取 PR 检查状态
gh pr checks "$PR_NUMBER" --json name,conclusion,detailsUrl

# 查看失败日志
gh pr checks "$PR_NUMBER" | grep "FAILURE" -A 5

# 查看具体 workflow run
gh run view <run-id> --log-failed
```

---

## p1 完成条件

| CI 状态 | 循环行为 | 说明 |
|---------|---------|------|
| FAILURE | continue | 修复后继续循环（不退出）|
| PENDING | continue | 等待 30 秒后继续循环 |
| SUCCESS | break | 合并 PR 后退出循环 |

---

## p2 阶段（CI pass）

**自动进入条件**：
- PR 存在
- CI 状态为 SUCCESS

**行为**：
- 在 P1 轮询循环中已自动合并
- Stop Hook 检测到 PHASE=p2
- 直接 `exit 0` 允许结束
- 进入 Learning/Cleanup（Step 10/11）

---

## 合并逻辑

**CI 通过后合并**：
- 在轮询循环中检测到 SUCCESS
- 使用 `gh pr merge --squash --delete-branch`
- 自动删除功能分支
- 退出循环，会话结束

---

## 注意事项

1. **持续轮询**：循环中使用 `sleep 30` 等待，不退出会话
2. **失败继续**：修复后 `continue` 继续循环，不要 `break`
3. **超时保护**：1 小时后自动退出，避免无限循环
4. **两阶段分离**：p0 不检查 CI，p1 才进入轮询循环
