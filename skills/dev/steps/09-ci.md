# Step 9: CI 轮询 + 自动修复循环

> P1 阶段：挂着轮询 CI，失败则修复，成功则合并
> **无限循环直到 PR 成功合并，用户无需介入**

---

## P1 轮询循环（三状态）

```
P1 阶段（无限循环，直到成功）：
  ┌─────────────────┐
  │ 状态1: 运行中   │ → 挂着轮询（sleep 30s 循环检查）
  └────────┬────────┘
           ↓
  ┌─────────────────┐
  │ 状态2: 失败     │ → 修复错误 → 推送 ──┐
  └─────────────────┘                    │
                                         │
  ┌─────────────────┐                    │
  │ 状态3: 成功     │ → 合并 → 完成      │
  └─────────────────┘                    │
           ↑                              │
           └──────────────────────────────┘
          （失败后修复，重新进入状态1）
```

---

## 核心循环逻辑

```bash
#!/usr/bin/env bash
set -euo pipefail

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  进入 P1 阶段：CI 轮询循环"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# 获取 PR 号
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number -q '.[0].number' 2>/dev/null)

if [ -z "$PR_NUMBER" ]; then
  echo "❌ 无法找到 PR"
  exit 1
fi

echo "PR #$PR_NUMBER"
echo ""

# 超时保护：最长等待 1 小时
MAX_WAIT_TIME=3600
START_TIME=$(date +%s)

# 无限循环，直到 CI 成功
while true; do
  # 检查超时
  CURRENT_TIME=$(date +%s)
  ELAPSED=$((CURRENT_TIME - START_TIME))

  if [ $ELAPSED -ge $MAX_WAIT_TIME ]; then
    echo "⚠️  超时（1小时），请手动检查 PR #$PR_NUMBER"
    echo "   URL: $(gh pr view $PR_NUMBER --json url -q '.url')"
    exit 1
  fi

  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "  检查 CI 状态... (已等待 ${ELAPSED}s)"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  # 获取最新 CI 运行状态
  CI_DATA=$(gh run list --branch "$BRANCH_NAME" --limit 1 --json databaseId,status,conclusion 2>/dev/null || echo "[]")

  if [ "$CI_DATA" = "[]" ] || [ -z "$CI_DATA" ]; then
    echo "⏳ CI 尚未启动，等待 30 秒..."
    sleep 30
    continue
  fi

  CI_STATUS=$(echo "$CI_DATA" | jq -r '.[0].status' 2>/dev/null || echo "unknown")
  CI_CONCLUSION=$(echo "$CI_DATA" | jq -r '.[0].conclusion' 2>/dev/null || echo "null")
  RUN_ID=$(echo "$CI_DATA" | jq -r '.[0].databaseId' 2>/dev/null)

  echo "状态: $CI_STATUS"
  echo "结论: $CI_CONCLUSION"
  echo ""

  # ========================================
  # 状态1: 运行中 - 挂着等待
  # ========================================
  if [ "$CI_STATUS" = "in_progress" ] || [ "$CI_STATUS" = "queued" ] || [ "$CI_STATUS" = "pending" ]; then
    echo "⏳ CI 运行中，等待 30 秒后重新检查..."
    sleep 30
    continue
  fi

  # ========================================
  # 状态2: 失败 - 修复并推送
  # ========================================
  if [ "$CI_STATUS" = "completed" ] && [ "$CI_CONCLUSION" = "failure" ]; then
    echo "❌ CI 失败！获取失败详情..."
    echo ""

    # 显示失败日志
    gh run view "$RUN_ID" --log-failed || echo "无法获取失败日志"

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  开始修复 CI 失败..."
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # 分析失败原因（这里需要 AI 介入）
    # 让调用者（AI）分析日志并修复代码
    # 修复完成后会 git add/commit/push

    echo "请分析上述失败日志并修复问题"
    echo "修复后提交并推送，然后继续循环"
    echo ""

    # 这里暂停，等待 AI 修复
    # AI 修复后会执行 git add/commit/push
    # 然后返回到这里继续循环

    # 注意：在实际执行中，这里不会真的"暂停"
    # 而是 AI 会分析失败、修复代码、提交、推送
    # 然后这个脚本继续执行，进入下一轮循环

    break  # 跳出循环，让 AI 修复
  fi

  # ========================================
  # 状态3: 成功 - 自动合并
  # ========================================
  if [ "$CI_STATUS" = "completed" ] && [ "$CI_CONCLUSION" = "success" ]; then
    echo "✅ CI 通过！准备合并 PR..."
    echo ""

    # 自动合并
    gh pr merge "$PR_NUMBER" --squash --delete-branch

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  ✅ PR 已成功合并"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # 退出循环
    break
  fi

  # 未知状态
  echo "⚠️  未知 CI 状态: status=$CI_STATUS, conclusion=$CI_CONCLUSION"
  echo "   等待 30 秒后重试..."
  sleep 30
done

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  P1 阶段完成"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
```

---

## CI 失败修复流程

当检测到 CI 失败时：

### 1. 获取失败详情

```bash
# 显示失败的 workflow run
gh run view "$RUN_ID" --log-failed

# 或查看具体 job
gh run view "$RUN_ID" --log
```

### 2. 分析失败原因

常见失败类型：

| 失败类型 | 关键词 | 修复方向 |
|---------|--------|---------|
| TypeCheck | `tsc --noEmit` | 类型错误修复 |
| Test | `vitest`, `jest` | 测试失败修复 |
| Build | `build failed` | 构建错误修复 |
| Lint | `eslint` | 代码风格修复 |
| Contract Drift | `drift detected` | 重新生成派生文件 |
| Evidence Gate | `SHA mismatch` | 更新 evidence 文件 |
| Impact Check | `registry not updated` | 更新 feature-registry |

### 3. 修复代码

根据失败类型修复代码。

### 4. 提交并推送

```bash
git add -A
git commit -m "fix: 修复 CI 失败 - <具体问题>

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

/usr/bin/git push origin HEAD
```

### 5. 继续循环

推送后，脚本会自动进入下一轮循环，等待新的 CI 运行。

---

## 超时保护

**默认超时**: 1 小时（3600 秒）

**超时后行为**：
- 输出警告信息
- 显示 PR URL
- 退出循环
- 需要人工介入

**调整超时时间**：

修改 `MAX_WAIT_TIME` 变量（单位：秒）。

---

## 状态转换图

```
         ┌──────────────┐
         │  PR 创建完成  │
         └──────┬───────┘
                ↓
         ┌──────────────┐
    ┌───▶│ 状态1: 运行中 │
    │    └──────┬───────┘
    │           │ CI 完成
    │           ↓
    │    ┌──────────────┐
    │    │  检查结论    │
    │    └──┬───────┬───┘
    │       │       │
    │ 失败  │       │ 成功
    │       ↓       ↓
    │  ┌─────────┐ ┌─────────┐
    └──│ 状态2:  │ │ 状态3:  │
       │ 修复    │ │ 合并    │
       └─────────┘ └────┬────┘
                        │
                        ↓
                   ┌─────────┐
                   │  完成   │
                   └─────────┘
```

---

## 与旧模式对比

**❌ 旧模式（事件驱动）**：
```
PR 创建 → 退出
CI fail → 用户问"怎么样了" → 检查 → 修复 → 推送 → 退出
         用户又问 → 检查 → 又失败 → 修复 → 推送 → 退出
         用户再问 → 检查 → 成功 → 合并
```

**✅ 新模式（轮询循环）**：
```
PR 创建 → 进入循环 → 运行中（sleep 30s）→ 失败 → 修复 → 推送
                   ↑___________________________________|
                   → 运行中（sleep 30s）→ 成功 → 合并 → 退出
```

**关键区别**：
- 旧：push 后退出，等用户问
- 新：push 后继续循环，自动检查

---

## 注意事项

1. **不退出会话**：整个 P1 阶段在一个会话中完成
2. **自动修复**：AI 分析日志并修复代码
3. **无限循环**：直到 CI 成功或超时
4. **超时保护**：避免无限挂起（1小时）
5. **自动合并**：CI 成功后自动 squash merge

---

## 错误处理

### gh CLI 失败

```bash
if ! gh pr view "$PR_NUMBER" &>/dev/null; then
  echo "❌ 无法访问 PR，请检查网络或权限"
  exit 1
fi
```

### 网络错误重试

CI 状态获取失败时，等待后重试（已内置在循环中）。

### 无法修复

如果连续多次失败（如 3 次），建议人工介入：

```bash
FAIL_COUNT=0
MAX_FAIL_COUNT=3

# 在失败分支
FAIL_COUNT=$((FAIL_COUNT + 1))
if [ $FAIL_COUNT -ge $MAX_FAIL_COUNT ]; then
  echo "❌ 连续失败 $FAIL_COUNT 次，请人工介入"
  exit 1
fi
```

---

## 完成条件

P1 阶段完成的唯一条件：

✅ **PR 成功合并**

其他所有情况都会继续循环或退出报错。
