# Step 9: CI 修复（p1 阶段）

> p1 阶段：事件驱动的 CI 修复循环
> **Stop Hook 强制执行：CI fail → 修复 → push → 退出 → 等下次唤醒**

---

## 阶段定义

**p1 阶段触发条件**：
- PR 已创建
- CI 状态为 FAILURE

**p1 阶段目标**：
- 修复 CI 失败问题
- Push 代码触发 CI 重跑
- 退出对话（不挂着等待）

---

## p1 事件驱动循环

```
┌─────────────────────────────────────────────────────┐
│           p1: CI fail 修复（事件驱动）               │
├─────────────────────────────────────────────────────┤
│                                                     │
│  阶段检测 (scripts/detect-phase.sh)                 │
│      → PHASE: p1                                    │
│      ↓                                              │
│  CI 修复循环 (Stop Hook 强制)                       │
│      │                                              │
│      │   1. 拉取 CI 失败详情                        │
│      │      gh pr checks <PR> --json ...            │
│      │                                              │
│      │   2. 分析失败原因                            │
│      │      - typecheck 失败 → 修复类型错误         │
│      │      - test 失败 → 修复测试                  │
│      │      - build 失败 → 修复构建                 │
│      │                                              │
│      │   3. 修复问题                                │
│      │                                              │
│      │   4. push 代码                               │
│      │      git add . && git commit && git push     │
│      │                                              │
│      │   5. 尝试结束对话                            │
│      │      Stop Hook:                              │
│      │        CI fail → exit 2（继续修）            │
│      │        CI pending → exit 0（退出，等唤醒）   │
│      │        CI pass → exit 0（结束）              │
│      ↓                                              │
│  结束对话 ✅ （不挂着等 CI）                         │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## Stop Hook 行为（p1）

**检查逻辑**：

```bash
# 1. 检测阶段
PHASE=$(bash scripts/detect-phase.sh | grep "^PHASE:" | awk '{print $2}')

# 2. p1 阶段检查 CI 状态
if [[ "$PHASE" == "p1" ]]; then
    CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state -q '.[].state' | head -1)

    if [[ "$CI_STATUS" == "PENDING" ]]; then
        # CI pending: 退出，等下次唤醒
        exit 0  # 允许结束（不挂着等 CI）

    elif echo "$CI_STATUS" | grep -qi "FAILURE"; then
        # CI fail: 阻止结束，继续修复
        echo "CI 失败，需要修复"
        echo "运行: gh pr checks $PR_NUMBER"
        exit 2  # 阻止会话结束

    elif echo "$CI_STATUS" | grep -qi "SUCCESS"; then
        # CI pass: 允许结束
        exit 0
    fi
fi
```

---

## 事件驱动 vs 无限循环

**❌ 旧模式（无限循环）**：
```bash
while true; do
    CI_STATUS=$(gh pr checks --watch)  # 挂着等
    if [[ "$CI_STATUS" == "pass" ]]; then
        break
    fi
    # 修复...
done
```

**✅ 新模式（事件驱动）**：
```bash
# 1. 修复代码
fix_code()

# 2. push 触发 CI
git push

# 3. 退出对话（不等 CI）
# Stop Hook: CI pending → exit 0

# 4. 等待外部唤醒
#    - CI fail 通知 → PHASE_OVERRIDE=p1 启动新会话
#    - 或手动检查后再次进入 p1
```

---

## CI 失败详情获取

```bash
# 获取 PR 检查状态
gh pr checks "$PR_NUMBER" --json name,conclusion,detailsUrl

# 查看失败日志
gh pr checks "$PR_NUMBER" | grep "FAILURE" -A 5

# 查看具体 workflow run
gh run view <run-id> --log-failed
```

---

## p1 完成条件

| CI 状态 | Stop Hook 行为 | 说明 |
|---------|---------------|------|
| FAILURE | exit 2 | 阻止结束，继续修复 |
| PENDING | exit 0 | 允许结束，等下次唤醒 |
| SUCCESS | exit 0 | 允许结束，进入 p2 |

---

## p2 阶段（CI pass）

**自动进入条件**：
- PR 存在
- CI 状态为 SUCCESS

**行为**：
- Stop Hook 检测到 PHASE=p2
- 直接 `exit 0` 允许结束
- GitHub Actions 自动 merge PR
- 进入 Learning/Cleanup（Step 10/11）

---

## pending 状态（中间态）

**定义**：
- PR 存在
- CI 状态为 PENDING/QUEUED

**行为**：
- 不是阶段，只是中间态
- Stop Hook 直接 `exit 0`
- 稍后再查（pending → fail/pass）

---

## PHASE_OVERRIDE 强制进入 p1

**用途**：CI fail 通知触发时，强制进入 p1

```bash
# n8n/GitHub Actions 触发
PHASE_OVERRIDE=p1 cecelia-run "修复 PR #123 的 CI 失败

当前 PR: #123
CI 状态: FAILURE

完成要求:
1. 查看 CI 失败详情
2. 修复问题
3. push 代码
4. 输出 <promise>DONE</promise>
"
```

**详细文档**：`docs/PHASE-OVERRIDE.md`

---

## 合并逻辑

**CI 通过后合并**：
- GitHub Actions 检查全部通过
- 使用 squash merge
- 合并后删除分支
- 自动触发，无需 AI 介入

---

## 注意事项

1. **不挂着等待**：push 后 CI pending 就退出，不要 `--watch`
2. **事件驱动**：每次 CI fail 通知唤醒一次，修复后退出
3. **Stop Hook 强制**：CI fail 时无法结束对话，必须修复
4. **两阶段分离**：p0 不检查 CI，p1 才检查 CI
