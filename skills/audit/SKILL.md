---
name: audit
description: |
  有边界的代码审计与修复。分层标准：L1阻塞性/L2功能性/L3最佳实践/L4过度优化。
  默认目标L2，L1+L2清零即宣布完成，防止无限深挖。
---

# /audit - 代码审计与修复

> 有边界的代码审计，避免无限深挖。

---

## 分层标准

| Layer | 名称 | 描述 | 完成标准 |
|-------|------|------|----------|
| **L1** | 阻塞性 | 功能不工作、崩溃、数据丢失 | **必须修** |
| **L2** | 功能性 | 边界条件、错误处理、已知 edge case | **建议修** |
| **L3** | 最佳实践 | 代码风格、一致性、可读性 | 可选 |
| **L4** | 过度优化 | 理论边界、极端情况、性能微调 | **不修** |

---

## 默认目标

**L2 完成 = 稳定可用**（推荐停止点）

```
用户说"找 bug"  → 做到 L2
用户说"深度审计" → 做到 L3
用户说"极致优化" → 警告用户，确认后做 L3
```

---

## 执行流程

### Step 1: 确定范围

```bash
# 询问用户
- 审计哪些文件/目录？
- 目标层级？（默认 L2）
- 最大轮次？（默认 3 轮）
```

### Step 2: 分层审计

```
第 1 轮：只找 L1 问题（阻塞性）
第 2 轮：找 L2 问题（功能性）
第 3 轮：如果用户要求，找 L3 问题
```

### Step 3: 每轮结束检查

```
问自己：
1. 这个问题会导致功能失败吗？ → L1
2. 这个问题会在边界情况出错吗？ → L2
3. 这个问题只是"可以更好"吗？ → L3，停止

如果找到的都是 L3/L4 问题 → 宣布审计完成
```

### Step 4: 完成声明

```
当以下条件满足时，主动声明审计完成：

✅ L1 问题：0 个
✅ L2 问题：0 个（或已全部修复）
✅ 连续 2 轮未发现新的 L1/L2 问题

输出：
"审计完成。L1/L2 问题已清零，剩余 N 个 L3 建议（可选修复）。"
```

---

## 问题分类示例

### L1 阻塞性（必须修）

- 脚本语法错误，无法执行
- 命令不存在，功能完全失效
- 条件判断错误，导致错误分支
- 文件路径错误，找不到依赖

### L2 功能性（建议修）

- 网络超时无保护，可能挂起
- 空字符串未处理，边界出错
- 错误码未正确返回
- 分支/路径引用不一致

### L3 最佳实践（可选）

- shebang 不统一
- set options 风格不同
- 变量命名不规范
- 注释不够清晰
- 硬编码的 magic numbers

### L4 过度优化（不修）

- 理论上可能的 word splitting（实际不会发生）
- 极端边界条件（需要刻意构造）
- 性能微优化（毫秒级差异）
- 代码"可以更优雅"

---

## 与 /dev 的关系

```
/dev 流程中的使用：

Step 4（写代码）完成后：
  - 可选调用 /audit 对新代码做 L1+L2 检查
  - 不阻塞 PR 创建

独立使用：
  - 用户主动调用 /audit
  - 按本 skill 流程执行
```

---

## 关键原则

1. **有边界**：明确知道什么时候停
2. **分层次**：不同问题不同对待
3. **主动完成**：达标后主动宣布完成，不等用户问
4. **抵制完美主义**：L3/L4 的诱惑要抵抗

---

## 反模式警告

❌ "我再找找看还有没有问题" → 无边界
❌ "这个地方可以更好" → L3/L4
❌ "理论上可能出问题" → L4
❌ "为了一致性统一改掉" → L3

✅ "L1/L2 已清零，审计完成"
✅ "发现 N 个 L3 建议，是否需要修复？"

---

## 快速参考

```
/audit           → L2 审计（默认）
/audit deep      → L3 审计（用户明确要求）
/audit <路径>    → 指定范围
```

---

**最后更新**: 2026-01-17
